{
  "hash": "68849c9d90ea1b158523ac8346e5653e",
  "result": {
    "markdown": "---\ntitle: Deep Sleep\necho: false\nexecute:\n  freeze: auto\n---\n\n<!-- ---\ntitle: \"\"\necho: false\njupyter: python3\nsection-divs: false\n--- -->\n\n\n\nDeep sleep is a power-saving mode on the ESP32 microcontroller that allows it to significantly reduce its power consumption by shutting down most of its components and functionalities. This mode is particularly useful for battery-powered applications where conserving energy is crucial.\n\n## Key Features of Deep Sleep\n\n1. **Low Power Consumption:**  \n    In deep sleep mode, the ESP32 consumes only a few microamps of current, drastically reducing power usage compared to its normal operating modes.\n1. **Preservation of Data:**  \n    The ESP32 can save the state of its peripherals and the values of certain variables in RTC (Real-Time Clock) memory, which is retained during deep sleep. This allows the microcontroller to resume tasks efficiently upon waking up.\n1. **Wake-Up Sources:**  \n    The ESP32 can be awakened from deep sleep by various events:\n    * Timer: The internal RTC can be programmed to wake the device after a specified time interval.\n    * External Pin: A change in the state of a designated GPIO pin can trigger a wake-up.\n    * Touch Sensor: Touch pad sensors can be used to wake up the device.\n    * ULP Coprocessor: The Ultra-Low-Power (ULP) coprocessor can run while the main CPU is in deep sleep and trigger a wake-up event based on sensor readings or other conditions.\n1. **Application Examples:**  \n    * Battery-Powered Sensors: Environmental sensors that need to periodically send data can spend most of their time in deep sleep, waking up only to take measurements and transmit data.\n    * IoT Devices: Devices that need to conserve power, such as remote weather stations or smart home devices, can use deep sleep to extend battery life.\n\n\n\n## Deep Sleep code\n\n```{=html}\n<button class=\"btn btn-outline-dark  rounded\" type=\"button\" data-bs-toggle=\"collapse\" data-bs-target=\"#deep_sleepino\" aria-expanded=\"false\" aria-controls=\"deep_sleepino\">\n    <i class=\"bi bi-toggles\"></i> Toggle code\n    </button>\n     <a class=\"btn btn-outline-dark rounded\", href=\"/archive/code/deep_sleep.ino\" download target=\"_blank\" rel=\"noopener noreferrer\">\n        <i class=\"bi bi-download\"></i> Download code\n    </a>\n```\n```{=html}\n\n            <div class=\"collapse\" id=\"deep_sleepino\">\n            <div class=\"card card-body border-0\">\n        \n```\n```{.c code-line-numbers=\"1\"}\n#define uS_TO_S_FACTOR 1000000ULL  /* Conversion factor for micro seconds to seconds */\n#define TIME_TO_SLEEP  10        /* Time ESP32 will go to sleep (in seconds) */\n\n\nvoid setup(){\n  Serial.begin(115200);\n  Serial.println(\"Good morning!\");\n  delay(2000); //Take some time to open up the Serial Monitor\n\n  // turn on LED\n  Serial.println(\"turn on LED\");\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, HIGH);\n  delay(2000); //Take some time to open up the Serial Monitor\n\n  /*\n  First we configure the wake up source\n  We set our ESP32 to wake up every TIME_TO_SLEEP seconds\n  */\n  esp_sleep_enable_timer_wakeup(TIME_TO_SLEEP * uS_TO_S_FACTOR);\n  Serial.println(\"Setup ESP32 to sleep for every \" + String(TIME_TO_SLEEP) +\n  \" Seconds\");\n\n  \n  Serial.println(\"Going to sleep now\");\n  Serial.flush(); \n  esp_deep_sleep_start();\n  Serial.println(\"This will never be printed\");\n}\n\nvoid loop(){\n  //This is not going to be called\n}\n\n```\n\n```{=html}\n\n            </div>\n            </div>\n            \n```\n\n\n## Deep Sleep wake with touch\nAdapted from [here](https://randomnerdtutorials.com/esp32-touch-wake-up-deep-sleep/).\n\n```{=html}\n<button class=\"btn btn-outline-dark  rounded\" type=\"button\" data-bs-toggle=\"collapse\" data-bs-target=\"#touch_wakeupino\" aria-expanded=\"false\" aria-controls=\"touch_wakeupino\">\n    <i class=\"bi bi-toggles\"></i> Toggle code\n    </button>\n     <a class=\"btn btn-outline-dark rounded\", href=\"/archive/code/touch_wakeup.ino\" download target=\"_blank\" rel=\"noopener noreferrer\">\n        <i class=\"bi bi-download\"></i> Download code\n    </a>\n```\n```{=html}\n\n            <div class=\"collapse\" id=\"touch_wakeupino\">\n            <div class=\"card card-body border-0\">\n        \n```\n```{.c code-line-numbers=\"1\"}\n/*\nDeep Sleep with Touch Wake Up\n=====================================\nThis code displays how to use deep sleep with\na touch as a wake up source and how to store data in\nRTC memory to use it over reboots\n\nESP32 can have multiple touch pads enabled as wakeup source\nESP32-S2 and ESP32-S3 supports only 1 touch pad as wakeup source enabled\n\nThis code is under Public Domain License.\n\nAuthor:\nPranav Cherukupalli <cherukupallip@gmail.com>\n*/\n\n#if CONFIG_IDF_TARGET_ESP32\n#define THRESHOLD 40   /* Greater the value, more the sensitivity */\n#else                  //ESP32-S2 and ESP32-S3 + default for other chips (to be adjusted) */\n#define THRESHOLD 5000 /* Lower the value, more the sensitivity */\n#endif\n\nRTC_DATA_ATTR int bootCount = 0;\ntouch_pad_t touchPin;\n/*\nMethod to print the reason by which ESP32\nhas been awaken from sleep\n*/\nvoid print_wakeup_reason() {\n  esp_sleep_wakeup_cause_t wakeup_reason;\n\n  wakeup_reason = esp_sleep_get_wakeup_cause();\n\n  switch (wakeup_reason) {\n    case ESP_SLEEP_WAKEUP_EXT0:     Serial.println(\"Wakeup caused by external signal using RTC_IO\"); break;\n    case ESP_SLEEP_WAKEUP_EXT1:     Serial.println(\"Wakeup caused by external signal using RTC_CNTL\"); break;\n    case ESP_SLEEP_WAKEUP_TIMER:    Serial.println(\"Wakeup caused by timer\"); break;\n    case ESP_SLEEP_WAKEUP_TOUCHPAD: Serial.println(\"Wakeup caused by touchpad\"); break;\n    case ESP_SLEEP_WAKEUP_ULP:      Serial.println(\"Wakeup caused by ULP program\"); break;\n    default:                        Serial.printf(\"Wakeup was not caused by deep sleep: %d\\n\", wakeup_reason); break;\n  }\n}\n\n/*\nMethod to print the touchpad by which ESP32\nhas been awaken from sleep\n*/\nvoid print_wakeup_touchpad() {\n  touchPin = esp_sleep_get_touchpad_wakeup_status();\n\n#if CONFIG_IDF_TARGET_ESP32\n  switch (touchPin) {\n    case 0:  Serial.println(\"Touch detected on GPIO 4\"); break;\n    case 1:  Serial.println(\"Touch detected on GPIO 0\"); break;\n    case 2:  Serial.println(\"Touch detected on GPIO 2\"); break;\n    case 3:  Serial.println(\"Touch detected on GPIO 15\"); break;\n    case 4:  Serial.println(\"Touch detected on GPIO 13\"); break;\n    case 5:  Serial.println(\"Touch detected on GPIO 12\"); break;\n    case 6:  Serial.println(\"Touch detected on GPIO 14\"); break;\n    case 7:  Serial.println(\"Touch detected on GPIO 27\"); break;\n    case 8:  Serial.println(\"Touch detected on GPIO 33\"); break;\n    case 9:  Serial.println(\"Touch detected on GPIO 32\"); break;\n    default: Serial.println(\"Wakeup not by touchpad\"); break;\n  }\n#else\n  if (touchPin < TOUCH_PAD_MAX) {\n    Serial.printf(\"Touch detected on GPIO %d\\n\", touchPin);\n  } else {\n    Serial.println(\"Wakeup not by touchpad\");\n  }\n#endif\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(1000);  //Take some time to open up the Serial Monitor\n\n  //Increment boot number and print it every reboot\n  ++bootCount;\n  Serial.println(\"Boot number: \" + String(bootCount));\n\n  //Print the wakeup reason for ESP32 and touchpad too\n  print_wakeup_reason();\n  print_wakeup_touchpad();\n\n#if CONFIG_IDF_TARGET_ESP32\n  //Setup sleep wakeup on Touch Pad 3 + 7 (GPIO15 + GPIO 27)\n  touchSleepWakeUpEnable(T3, THRESHOLD);\n  touchSleepWakeUpEnable(T7, THRESHOLD);\n\n#else  //ESP32-S2 + ESP32-S3\n  //Setup sleep wakeup on Touch Pad 3 (GPIO3)\n  touchSleepWakeUpEnable(T3, THRESHOLD);\n\n#endif\n\n  //Go to sleep now\n  Serial.println(\"Going to sleep now\");\n  esp_deep_sleep_start();\n  Serial.println(\"This will never be printed\");\n}\n\nvoid loop() {\n  //This will never be reached\n}\n\n```\n\n```{=html}\n\n            </div>\n            </div>\n            \n```\n\n\n## Save values between sleeps\nRecommended tutorial [here](https://randomnerdtutorials.com/esp32-save-data-permanently-preferences/).\n\n```{=html}\n<button class=\"btn btn-outline-dark  rounded\" type=\"button\" data-bs-toggle=\"collapse\" data-bs-target=\"#save_valuesino\" aria-expanded=\"false\" aria-controls=\"save_valuesino\">\n    <i class=\"bi bi-toggles\"></i> Toggle code\n    </button>\n     <a class=\"btn btn-outline-dark rounded\", href=\"/archive/code/save_values.ino\" download target=\"_blank\" rel=\"noopener noreferrer\">\n        <i class=\"bi bi-download\"></i> Download code\n    </a>\n```\n```{=html}\n\n            <div class=\"collapse\" id=\"save_valuesino\">\n            <div class=\"card card-body border-0\">\n        \n```\n```{.c code-line-numbers=\"1\"}\n/*\nGood tutorial\nhttps://randomnerdtutorials.com/esp32-save-data-permanently-preferences/\n*/\n#include <Preferences.h> // Include the Preferences library\n\n#define uS_TO_S_FACTOR 1000000ULL  /* Conversion factor for microseconds to seconds */\n#define TIME_TO_SLEEP  10          /* Time ESP32 will go to sleep (in seconds) */\n\nPreferences preferences;           // Create a Preferences object\n\nvoid setup() {\n  Serial.begin(115200);\n  Serial.println(\"Good morning!\");\n  delay(100); // Take some time to open up the Serial Monitor\n\n  // Turn on LED\n  Serial.println(\"Turn on LED\");\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, HIGH);\n  delay(2000);\n\n  // Open Preferences in RW mode\n  preferences.begin(\"my-app\", false); // \"my-app\" is the namespace, false = read/write mode\n\n  // Retrieve stored values\n  int storedInt = preferences.getInt(\"myInt\", 0);      // Default value is 0 if not set\n  float storedFloat = preferences.getFloat(\"myFloat\", 0.0); // Default is 0.0\n  String storedString = preferences.getString(\"myString\", \"Default\");\n\n  Serial.println(\"Retrieved values from flash:\");\n  Serial.println(\"Int: \" + String(storedInt));\n  Serial.println(\"Float: \" + String(storedFloat));\n  Serial.println(\"String: \" + storedString);\n\n  // Increment and store new values\n  storedInt++;\n  storedFloat += 1.5;\n  storedString = \"Wake #\" + String(storedInt);\n\n  preferences.putInt(\"myInt\", storedInt);\n  preferences.putFloat(\"myFloat\", storedFloat);\n  preferences.putString(\"myString\", storedString);\n\n  Serial.println(\"Stored updated values in flash:\");\n  Serial.println(\"Int: \" + String(storedInt));\n  Serial.println(\"Float: \" + String(storedFloat));\n  Serial.println(\"String: \" + storedString);\n\n  // Close Preferences\n  preferences.end();\n\n  // Configure the wake-up source\n  esp_sleep_enable_timer_wakeup(TIME_TO_SLEEP * uS_TO_S_FACTOR);\n  Serial.println(\"Setup ESP32 to sleep for every \" + String(TIME_TO_SLEEP) + \" seconds\");\n\n  Serial.println(\"Going to sleep now\");\n  Serial.flush();\n  esp_deep_sleep_start();\n\n  Serial.println(\"This will never be printed\");\n}\n\nvoid loop() {\n  // This is not going to be called\n}\n\n```\n\n```{=html}\n\n            </div>\n            </div>\n            \n```\n\n\n",
    "supporting": [
      "deep_sleep_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}