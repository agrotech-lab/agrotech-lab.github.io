[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "agrotech lab",
    "section": "",
    "text": "About\nWelcome to the Agrotech-lab course, where you will have the opportunity to learn about the integration of microcontrollers in agriculture technology. In this course, you will explore the use of microcontrollers such as the ESP32 and how they can be utilized to automate processes, collect data, and improve overall efficiency in agricultural practices.\nThroughout the course, you will gain practical knowledge on how to design, develop, and implement microcontroller-based solutions for different applications in agriculture. You will learn how to use sensors to collect data such as temperature, humidity, and soil moisture, and how to integrate this data with the ESP32 to automate irrigation systems, monitor plant growth, and more.\nThis course is designed for students who are interested in the application of technology in agriculture and want to gain hands-on experience in designing and implementing microcontroller-based solutions. By the end of this course, you will have a solid understanding of how to apply microcontrollers in agricultural practices, which will equip you with valuable skills for future research or professional opportunities."
  },
  {
    "objectID": "index.html#iconify-fa-solid-user-ninja-mission",
    "href": "index.html#iconify-fa-solid-user-ninja-mission",
    "title": "agrotech lab",
    "section": " Mission",
    "text": "Mission\nWe are here to have some fun!"
  },
  {
    "objectID": "index.html#iconify-mdi-head-lightbulb-learning-experience",
    "href": "index.html#iconify-mdi-head-lightbulb-learning-experience",
    "title": "agrotech lab",
    "section": " Learning experience",
    "text": "Learning experience\nWe want students to creatively engage with their projects, finding by themselves solutions to the challenges they encounter. The role of the teaching staff will be to consult and advise, not spoon-feed solutions.\nThe main values we would like to promote: curiosity, independence, creativity, and a can-do attitude."
  },
  {
    "objectID": "index.html#iconify-mdi-scroll-text-outline-course-policy-and-grading",
    "href": "index.html#iconify-mdi-scroll-text-outline-course-policy-and-grading",
    "title": "agrotech lab",
    "section": " Course policy and grading",
    "text": "Course policy and grading\n\n10%: Presence. 100% presence is required.\n10%: Equipment: borrowing and returning. All equipment must be accounted for and taken care with respect. Together we will keep record of all borrowed equipment. Everything will be neatly return to storage by 10 July.\n40%: Homework.\n40%: Final project.\n\n25%: Experimental setup.\n20%: Report.\n5%: Presentation."
  },
  {
    "objectID": "index.html#iconify-eva-email-outline-contact-the-staff",
    "href": "index.html#iconify-eva-email-outline-contact-the-staff",
    "title": "agrotech lab",
    "section": " Contact the staff",
    "text": "Contact the staff\nLecturers\nErez Feuer: erez.feuer@mail.huji.ac.il\nYair Mau: yair.mau@mail.huji.ac.il (on sabbatical for 2025-2026 class)\nTA\nGal Tzvik: gal.tzvik@mail.huji.ac.il"
  },
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "Schedule",
    "section": "",
    "text": "Wednesdays, from 17:00 to 20:00\n In the lab next to the “Ground Water” seminar room, 1st floor\n Map\n\n\n\n\n\ndate\ntopic\n\n\n\n\n2025-10-22\nCourse overview, what is agrotech, microcontrollers, examples, AI. Arduino IDE.\n\n\n2025-10-29\nBasic electronics: multimeter, Ohm’s law, and circuitry.\n\n\n2025-11-05\nBasic projects, circuits on breadboard, sensors, Thingspeak. mid project rundown.\n\n\n2025-11-12\nBasic projects, circuits on breadboard, sensors, Thingspeak. mid project rundown.\n\n\n2025-11-19\ndigital signals, sensors and data logging\n\n\n2025-11-26\ncontrol, feedback\n\n\n2025-12-03\nMQTT, power management, guest speaker\n\n\n2025-12-10\nfinal projects meetings soldering and assembly\n\n\n2025-12-17\nNO CLASS\n\n\n2025-12-24\nNO CLASS — Christmas\n\n\n2025-12-31\nproject development\n\n\n2026-01-07\nproject development\n\n\n2026-01-14\nproject development\n\n\n2026-01-21\nproject presentation"
  },
  {
    "objectID": "arduino-intro-and-links.html#what-is-a-microcontroller",
    "href": "arduino-intro-and-links.html#what-is-a-microcontroller",
    "title": "1  Arduino intro",
    "section": "1.1 What is a microcontroller?",
    "text": "1.1 What is a microcontroller?\nA microcontroller, also known as an MCU, is a tiny computer that is capable of performing a variety of tasks. It is a single metal-oxide-semiconductor (MOS) integrated circuit (IC) chip that contains one or more central processing units (CPUs), memory, and programmable input/output peripherals. The MCU can receive input from various sensors and devices, process that input, and provide an output to control other devices."
  },
  {
    "objectID": "arduino-intro-and-links.html#arduino",
    "href": "arduino-intro-and-links.html#arduino",
    "title": "1  Arduino intro",
    "section": "1.2 Arduino",
    "text": "1.2 Arduino\nOne popular brand of microcontrollers is Arduino. Arduino is a company that produces user-friendly microcontroller boards, such as the Arduino Uno, Arduino Mega, and Arduino Nano. These boards are widely used and have extensive documentation and online resources available. The Arduino board contains a microcontroller chip, memory, and input/output pins that can be used to interface with other electronic components such as sensors, motors, LEDs, and displays.\nThe Arduino board can be programmed using a simplified version of the C++ programming language, which makes it accessible for beginners to learn and use. The board is also open-source, meaning that anyone can access and modify the hardware and software designs."
  },
  {
    "objectID": "arduino-intro-and-links.html#applications",
    "href": "arduino-intro-and-links.html#applications",
    "title": "1  Arduino intro",
    "section": "1.3 Applications",
    "text": "1.3 Applications\nArduino is being used for a wide variety of applications, including home automation, robotics, environmental monitoring, and education. For instance, Arduino can be used to control lights, fans, and other appliances in a home automation system. It is popular among hobbyists and students for building robots and automated systems. Lastly, Arduino is widely used to monitor temperature, humidity, and other environmental factors for research or industrial applications."
  },
  {
    "objectID": "arduino-intro-and-links.html#esp32-arduino2-wifi-bluetooth",
    "href": "arduino-intro-and-links.html#esp32-arduino2-wifi-bluetooth",
    "title": "1  Arduino intro",
    "section": "1.4 ESP32 = Arduino\\(^2\\) + WiFi + Bluetooth",
    "text": "1.4 ESP32 = Arduino\\(^2\\) + WiFi + Bluetooth\nHowever, in this course, we will not be using Arduino boards. Instead, we will be using the ESP32 microcontroller (to be exact, the FIreBeetle 2 ESP32 board), which is similar to Arduino in terms of its programming environment, but has additional features such as built-in WiFi and Bluetooth capabilities. This makes it ideal for internet of things (IoT) projects and wireless communication. The ESP32 is also affordable, with boards costing around $5 each.\nThroughout this course, you will learn how to program the ESP32 to control various electronic devices. You will learn how to interface the ESP32 with sensors, motors, displays, and other devices. By the end of this course, you will have the skills and knowledge to create your own custom microcontroller projects.\nSo get ready to dive into the exciting world of microcontrollers with the ESP32!"
  },
  {
    "objectID": "tutorials/arduino_IDE.html#what-is-arduino-ide",
    "href": "tutorials/arduino_IDE.html#what-is-arduino-ide",
    "title": "2  Arduino IDE",
    "section": "2.1 What is Arduino IDE?",
    "text": "2.1 What is Arduino IDE?\nArduino IDE (Integrated Development Environment) is a software application that is used to write and upload code to MCU boards. Arduino IDE code is written in C or C++ programming language. It is a free and open-source platform that makes it easy for beginners to get started with Arduino programming.\nArduino IDE comes with a text editor, a code library, and a serial monitor that allows you to communicate with your Arduino board. It is available for Windows, Mac, and Linux operating systems."
  },
  {
    "objectID": "tutorials/arduino_IDE.html#how-to-install-arduino-ide",
    "href": "tutorials/arduino_IDE.html#how-to-install-arduino-ide",
    "title": "2  Arduino IDE",
    "section": "2.2 How to Install Arduino IDE?",
    "text": "2.2 How to Install Arduino IDE?\nFollow these simple steps to install Arduino IDE on your computer:"
  },
  {
    "objectID": "tutorials/arduino_IDE.html#step-1-download",
    "href": "tutorials/arduino_IDE.html#step-1-download",
    "title": "2  Arduino IDE",
    "section": "2.3 Step 1: Download",
    "text": "2.3 Step 1: Download\nGo to the official Arduino website and download the latest version of the Legacy IDE (1.8.X) for your operating system. Don’t download version 2.0.X, it will work for you but all the tutorials we will be following are in the previouse version (1.8.X)."
  },
  {
    "objectID": "tutorials/arduino_IDE.html#step-2-install-arduino-ide",
    "href": "tutorials/arduino_IDE.html#step-2-install-arduino-ide",
    "title": "2  Arduino IDE",
    "section": "2.4 Step 2: Install Arduino IDE",
    "text": "2.4 Step 2: Install Arduino IDE\nOnce the download is complete, run the installer and follow the on-screen instructions to install Arduino IDE on your computer.\n\nCongratulations, you have successfully installed Arduino IDE on your computer and you are ready to start programming your MCU!"
  },
  {
    "objectID": "tutorials/arduino_IDE.html#how-to-use-arduino-ide",
    "href": "tutorials/arduino_IDE.html#how-to-use-arduino-ide",
    "title": "2  Arduino IDE",
    "section": "2.5 How to use Arduino IDE?",
    "text": "2.5 How to use Arduino IDE?\nIn this guide, we will explain the basics of Arduino IDE code and how to write your own Arduino programs.\n\n2.5.1 The Arduino IDE\nThe Arduino Integrated Development Environment (IDE) is a software development platform for creating programs that run on Arduino boards. The IDE includes a code editor, a compiler, and a firmware uploader. You can use the IDE to write, edit, and upload your Arduino programs.\n\n\n2.5.2 The Setup and Loop Functions\nIn the Arduino IDE, every program must have two functions: setup() and loop(). The setup() function is called only once when the program starts, and it is used to initialize the program and set up any necessary variables. The loop() function, on the other hand, is called repeatedly after the setup() function, and it is used to run the main program logic.\n\n\n2.5.3 Libraries\nLibraries are prewritten pieces of code that you can use in your Arduino programs. Libraries contain functions and variables that you can use to make your programming tasks easier. You can include libraries in your program by using the #include directive at the beginning of your program.\n\n\n2.5.4 Variables\nVariables are used to store values in your program. In Arduino programming, you need to declare your variables at the beginning of your program. To declare a variable, you need to specify its data type and name. For example, int myVariable = 10; declares an integer variable called myVariable and assigns it the value 10.\n\n\n2.5.5 Functions\nFunctions are blocks of code that perform a specific task. In Arduino programming, functions can be used to simplify your program and make it easier to read and understand. To create a function, you need to specify its return type, name, and any arguments it requires. For example, int my_function(int arg1, int arg2) creates a function called my_function that takes two integer arguments and returns an integer value.\n\n\n2.5.6 Putting It All Together\nNow that you understand the basic elements of Arduino programming, you can start writing your own programs. To get started, you can follow these steps:\n\nOpen the Arduino IDE and create a new sketch.\nWrite your program code in the setup() and loop() functions.\nDeclare any variables and functions you need at the beginning of your program.\nInclude any libraries you need by using the #include directive.\nUpload your program to your Arduino board by clicking the upload button in the IDE."
  },
  {
    "objectID": "tutorials/arduino_IDE.html#conclusion",
    "href": "tutorials/arduino_IDE.html#conclusion",
    "title": "2  Arduino IDE",
    "section": "2.6 Conclusion",
    "text": "2.6 Conclusion\nArduino IDE code is an essential part of Arduino programming. Understanding the basics of Arduino IDE code, including the setup() and loop() functions, libraries, variables, and functions, is essential for creating your own Arduino programs. With practice and patience, you can become proficient in Arduino programming and develop exciting projects using the Arduino platform."
  },
  {
    "objectID": "tutorials/arduino_IDE.html#example",
    "href": "tutorials/arduino_IDE.html#example",
    "title": "2  Arduino IDE",
    "section": "2.7 Example",
    "text": "2.7 Example\n// Include the necessary library for controlling the digital pin\n#include &lt;Arduino.h&gt;\n\n// Define the pin number for the LED\nconst int LED_PIN = 13;\n\nvoid setup() {\n  // Set the LED pin as an output\n  pinMode(LED_PIN, OUTPUT);\n}\n\nvoid loop() {\n  // Turn the LED on\n  digitalWrite(LED_PIN, HIGH);\n\n  // Wait for 1 second\n  delay(1000);\n\n  // Turn the LED off\n  digitalWrite(LED_PIN, LOW);\n\n  // Wait for another second\n  delay(1000);\n}\nLet’s break down each part of the program:\n#include &lt;Arduino.h&gt;\nThis line includes the Arduino library, which contains functions for controlling the digital pins on the Arduino board.\nconst int LED_PIN = 13;\nThis line defines a constant integer variable called LED_PIN and assigns it the value 13. This is the pin number that the LED is connected to.\nvoid setup() {\n  // Set the LED pin as an output\n  pinMode(LED_PIN, OUTPUT);\n}\nThis is the setup() function, which is called once when the program starts. In this function, we set the LED pin as an output by calling pinMode(LED_PIN, OUTPUT).\nvoid loop() { ... }\nThis is the loop() function, which is called repeatedly after the setup() function. In this function, we turn the LED on by calling digitalWrite(LED_PIN, HIGH) and then wait for 1 second by calling delay(1000). We then turn the LED off by calling digitalWrite(LED_PIN, LOW) and wait for another second.\n  // Turn the LED on\n  digitalWrite(LED_PIN, HIGH);\n\n  // Wait for 1 second\n  delay(1000);\n\n  // Turn the LED off\n  digitalWrite(LED_PIN, LOW);\n\n  // Wait for another second\n  delay(1000);\nThese two lines turn the LED on and off by setting the voltage of the LED pin to HIGH and LOW, respectively.\ndelay(1000);\nThis line causes the program to pause for 1 second (1000 milliseconds) before continuing. The delay() function is used to control the timing of the program.\nOverall, this program is very simple, but it demonstrates the basic structure of an Arduino program. The setup() function is used to initialize the program, while the loop() function is used to perform the main program logic. The program uses the digitalWrite() function to turn the LED on and off, and the delay() function to control the timing of the program. By understanding these basic concepts, you can start to build more complex programs on the Arduino platform."
  },
  {
    "objectID": "tutorials/install_firebeetle.html#how-to-connect-the-firebeetle-2-mcu",
    "href": "tutorials/install_firebeetle.html#how-to-connect-the-firebeetle-2-mcu",
    "title": "3  Install FireBeetle (ESP32)",
    "section": "3.1 How to connect the Firebeetle 2 MCU",
    "text": "3.1 How to connect the Firebeetle 2 MCU\nIn our class we will be using the FireBeetle 2 ESP32-E IoT Microcontroller as our main MCU. In this guid you will learn how to install needed software on your computer.\nFull documentation of this MCU can be found on the product wiki by DFRobot. For a quick pinout reference, take a look at this page.\n\nFollow these simple steps to install FireBeetle 2 MCU on the Arduino IDE on your computer:\n\nAdd the json link in IDE\nDownload the core of the maincontroller\nSelect development board and serial port\n\n\n3.1.1 Add URL to Ardudino IDE\nTo install the ESP32 board in your Arduino IDE, follow these next instructions:\nIn your Arduino IDE, go to File&gt; Preferences\n\nEnter the following into the “Additional Board Manager URLs” field:\nhttps://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json\nThen, click the “OK” button:\n\nNote: if you already have a different URL, you can separate the URLs with a comma as follows:\nhttp://download.dfrobot.top/FireBeetle/package_DFRobot_index.json, https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json\nOpen the Boards Manager. Go to Tools &gt; Board &gt; Boards Manager\n\nSearch for ESP32 and press install button for the “ESP32 by Espressif Systems”. Make sure the version is 2.0.7 or later.\n\nThat’s it. The installation can take a few minutes. Take a break.\n\n\n\n3.1.2 Select board and port\nOnce the board is installed, select it: Open Tools-&gt;Board-&gt;ESP32 Arduino-&gt;FireBeetle 2 ESP32-E \nThen select the Port\nOpen Tools-&gt;Port-&gt;COMxx (for windows the port wil be COM with some number, for Mac/linux it will be /dev/cu. and then something).\nHow do you know what port to choose?\nCheck the ports without the MCU pluged into the computer. Then plug the MCU and check the ports again. If you see a new port, thats the port of the MCU."
  },
  {
    "objectID": "tutorials/install_firebeetle.html#troubleshooting",
    "href": "tutorials/install_firebeetle.html#troubleshooting",
    "title": "3  Install FireBeetle (ESP32)",
    "section": "3.2 Troubleshooting",
    "text": "3.2 Troubleshooting\nTroubleshooting if there is no port for the MCU:\n\nMissing driver. Could be you need to install a specific driver.\nWindows driver\nMacOS driver\nBad USB cable. Some cables are bad and some are only for charging and cannot sync data. Try using a different USB cable that worked for a freind."
  },
  {
    "objectID": "tutorials/breadboard.html",
    "href": "tutorials/breadboard.html",
    "title": "4  Breadboard",
    "section": "",
    "text": "A breadboard is a device used to prototype electronic circuits without the need for soldering. It consists of a plastic board with rows of holes, each of which is connected to others in the same row. In addition, there are two vertical columns on the sides of the board, which are known as the + and - rails. The + rail is typically used to connect positive voltage sources, while the - rail is used to connect negative voltage sources or the ground. When a component, such as a resistor, capacitor, or LED, is inserted into a hole on the breadboard, it makes contact with the metal strip that runs underneath the holes, which provides electrical connectivity between the components. This allows multiple components to be connected together to form a circuit. Breadboards are commonly used by hobbyists, students, and engineers to quickly prototype and test electronic circuits before they are soldered onto a printed circuit board.\nVery good tutorials on how to use a breadboard:\n\nwiring.org\nsparkfun\n\n\n\n\nbreadboard wiring diagram"
  },
  {
    "objectID": "tutorials/basic-electronics-concepts.html#very-basic-concepts",
    "href": "tutorials/basic-electronics-concepts.html#very-basic-concepts",
    "title": "5  Basic Electronics Concepts",
    "section": "5.1 Very Basic Concepts",
    "text": "5.1 Very Basic Concepts\nYou should be familiar with the very basics of how electricity works. There are a million books and websites to learn from. We suggest the following webpages, written by Sparkfun, a big vendor of electronics.\n\nWhat is Electricity?\nElectric Power\nVoltage, Current, Resistance, and Ohm’s Law\nWhat is a Circuit?\nHow to Use a Multimeter\nVoltage Dividers\nHow to Use a Breadboard\n\nThere is no end to learning about these topics! The good news is that you can accomplish a lot of stuff with the very basic notions of electric circuits. If you want to learn even more, navigate your way on the “Suggested Reading” section in the tutorials above."
  },
  {
    "objectID": "tutorials/basic-electronics-concepts.html#other-links",
    "href": "tutorials/basic-electronics-concepts.html#other-links",
    "title": "5  Basic Electronics Concepts",
    "section": "5.2 Other Links",
    "text": "5.2 Other Links\n\n5.2.0.1 What is an LED?\n\nFrom electronics-tutorials.ws\nFrom Sparkfun\n\n\n\n5.2.0.2 Thermistor Tutorial\n\nFrom Adafruit\nModel equations and calculator of constants for thermistors"
  },
  {
    "objectID": "tutorials/firebeetle_documentation.html#board-overview",
    "href": "tutorials/firebeetle_documentation.html#board-overview",
    "title": "6  FireBeetle 2 ESP32-E",
    "section": "6.1 Board Overview",
    "text": "6.1 Board Overview\n\n\n\nboard overview\n\n\n\n\n\n\n\n\n\n\nNo.\nFunction\nDescription\n\n\n\n\n①\nUSB Interface\nProgram download and power supply, 4.75V-5.5V compatible\n\n\n②\nCharging Indicator\nRed LED for indicating charging status: 1. Off when fully charged or not charged; 2. On when charging; 3. Quick flash when powered by USB, and no battery connected.\n\n\n③\nUser Button\nControlled by pin IO27/D4\n\n\n④\nLi-ion Battery Port\nSupport 3.5V-4.2V\n\n\n⑤\nOnboard RGB Light\nWS2812 RGB LED, controlled by pin IO5/D8\n\n\n⑥\nOnboard LED\nLED controlled by pin IO2/D9\n\n\n⑦\nReset Button\nPress to reset program\n\n\n⑧\nLow-power Solder Jumper\nPad Designed for low power mode and default to be connected. Slightly cut off the thin wire with a knife to disconnect it. When disconnected, static power consumption can be reduced by 500 μA. The power consumption can be reduced to 13 μA after controlling the main controller to enter the sleep mode through the program. Note: when the pad is disconnected, you can only drive RGB LED light via the USB Power supply.\n\n\n⑨\nGDI\nDFRobot dedicated Display interface. Refer to the GDI part of this page.\n\n\n⑩\nESP32-E Chip\nESP32-WROOM-32E"
  },
  {
    "objectID": "tutorials/firebeetle_documentation.html#pinout",
    "href": "tutorials/firebeetle_documentation.html#pinout",
    "title": "6  FireBeetle 2 ESP32-E",
    "section": "6.2 PinOut",
    "text": "6.2 PinOut\n\n\n\nPinout\n\n\n\n\n\n\n\n\n\nCategory\nDescription\n\n\n\n\nControl\nFireBeetle enable/reset pins\n\n\nTouch\nPin with capacitive touch function\n\n\nAnalog\nAnalog pin\n\n\nPort PIN\nDefault physical pin number of the chip, which can be used to directly control the corresponding pin\n\n\nArduino IDE\nIn Arduino IDE, the pin numbers have been remapped by FireBeetle, and you can directly use this symbol to control the corresponding pin\n\n\nRTC PIN\nFireBeetle 2 ESP32-E supports low power function, and in Deep-sleep mode, only RTC pin keeps working and can be used as a wave-up source. When RTC pin is used as an output pin, it keeps outputting level value when the chip is in Deep-sleep mode, while as an input pin, it can wake up the chip from Deep-sleep.\n\n\nGND\nCommon ground for all power supplies and logics\n\n\nPower\nWhen powered by 5V-USB, VCC outputs about 4.7V and 3V3 outputs 3.3V; When powered by 4V li-ion battery, VCC outputs about 4V and 3V3 outputs 3.3V(Actual measurement)"
  },
  {
    "objectID": "tutorials/libraries.html#using-the-library-manager",
    "href": "tutorials/libraries.html#using-the-library-manager",
    "title": "7  Libraries",
    "section": "7.1 Using the Library Manager",
    "text": "7.1 Using the Library Manager\nThe Library Manager is the easiest and most straightforward way of installing libraries in the Arduino IDE. Follow these steps:\n\nOpen the Arduino IDE and navigate to Sketch &gt; Include Library &gt; Manage Libraries...\nIn the Library Manager window, type the name of the library you want to install in the search bar. You can also browse through the available libraries by clicking on any of the categories on the left-hand side.\nOnce you have found the library you want to install, click on it and then click the Install button.\nWait for the installation process to complete. You can check the progress in the progress bar at the bottom of the window.\nOnce the installation is complete, close the Library Manager window.\nTo include the library in your sketch, navigate to Sketch &gt; Include Library and select the library you just installed."
  },
  {
    "objectID": "tutorials/libraries.html#manually-installing-a-library-from-github",
    "href": "tutorials/libraries.html#manually-installing-a-library-from-github",
    "title": "7  Libraries",
    "section": "7.2 Manually Installing a Library from GitHub",
    "text": "7.2 Manually Installing a Library from GitHub\nSometimes, the library you need is not available in the Library Manager, or you may want to install a specific version of a library that is not the latest. In such cases, you can manually download the library from GitHub and install it in the Arduino IDE. Follow these steps:\n\nOpen the GitHub repository of the library you want to install and click on the green Code button.\nSelect Download ZIP and save the zip file to your computer.\nOpen the Arduino IDE and navigate to Sketch &gt; Include Library &gt; Add .ZIP Library...\nSelect the zip file you just downloaded and click the Open button.\nWait for the installation process to complete. You can check the progress in the progress bar at the bottom of the window.\nOnce the installation is complete, close the Library Manager window.\nTo include the library in your sketch, navigate to Sketch &gt; Include Library and select the library you just installed."
  },
  {
    "objectID": "tutorials/libraries.html#conclusion",
    "href": "tutorials/libraries.html#conclusion",
    "title": "7  Libraries",
    "section": "7.3 Conclusion",
    "text": "7.3 Conclusion\nInstalling libraries in the Arduino IDE is a straightforward process that can save you a lot of time and effort in your projects. Whether you prefer using the Library Manager or manually downloading libraries from GitHub, there is a solution for everyone."
  },
  {
    "objectID": "tutorials/first-programs.html#blink",
    "href": "tutorials/first-programs.html#blink",
    "title": "8  First programs",
    "section": "8.1 Blink",
    "text": "8.1 Blink\nIt’s time to run a first example.\n\nGo to File &gt; Examples &gt; 01.Basics, click on Blink.\nPress the  “right arrow” button on the top left to upload the code onto the ESP32.\nWhen you see “Connecting” on the bottom of the screen, press the right button on the ESP32.\n\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n// the setup function runs once when you press reset or power the board\nvoid setup() {\n  // initialize digital pin LED_BUILTIN as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n  digitalWrite(LED_BUILTIN, HIGH);   // turn the LED on (HIGH is the voltage level)\n  delay(1000);                       // wait for a second\n  digitalWrite(LED_BUILTIN, LOW);    // turn the LED off by making the voltage LOW\n  delay(500);                       // wait for 500 milliseconds\n}\n\n            \n            \n            \n\nThe following is a slight variation of the code above. It requires you to:\n\nconnect the ESP32 to a breadboard\nconnect the long leg of an LED to the A4 pin\nconnect a 330-ohm resistor between the short LED leg and ground\n\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nconst int LED_pin = A4;\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n  // initialize digital pin LED_BUILTIN as an output.\n  pinMode(LED_pin, OUTPUT);\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n  digitalWrite(LED_pin, HIGH);   // turn the LED on (HIGH is the voltage level)\n  delay(1000);                       // wait for a second\n  digitalWrite(LED_pin, LOW);    // turn the LED off by making the voltage LOW\n  delay(1000);                       // wait for a second\n}"
  },
  {
    "objectID": "tutorials/first-programs.html#printing-increasing-numbers",
    "href": "tutorials/first-programs.html#printing-increasing-numbers",
    "title": "8  First programs",
    "section": "8.2 Printing increasing numbers",
    "text": "8.2 Printing increasing numbers\nUpload the following code to your ESP32, then click on the  on the top right corner. This is called “Serial Monitor”.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n// This is a one-line comment\n\n/*\nThis\ncomment\nspans\nmany\nrows\n*/\n\nint num = 0;              // integer \n\nvoid setup() {\n  /* initialize serial communication with computer\n   * baud rate 9600 = 9600 bits per second\n   */ \n  Serial.begin(9600);\n}\n\nvoid loop() {\n  // print num and break line\n  Serial.println(num);\n  // print num, don't break line\n  // Serial.print(num);\n  delay(1000);        // 1000 ms delay\n  num = num + 1;      // increase num by 1\n}\n\n/*\n * 1. To see the numbers go to\n * Tools &gt; Serial Plotter\n * 2. After you see the numbers,\n * press the ESP32 reset button and see what happens\n * 3. In the Serial Plotter window,\n * change baud rate to another number, see what happens \n */"
  },
  {
    "objectID": "tutorials/first-programs.html#printing-random-numbers-then-plotting",
    "href": "tutorials/first-programs.html#printing-random-numbers-then-plotting",
    "title": "8  First programs",
    "section": "8.3 Printing random numbers, then plotting!",
    "text": "8.3 Printing random numbers, then plotting!\n\nUpload the following code to your ESP32.\nOpen the Serial Monitor (). Now close it, and\nGo to Tools &gt; Serial Plotter.\n\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nint num1 = 0, num2 = 0;\n\nvoid setup() {\n  // initialize serial communication with computer:\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  // random(min, max)\n  num1 = num1 + random(-5, 5);\n  num2 = num2 + random(-10, 10);\n  // print num1, then tab, then num2, then break line\n  Serial.print(num1);\n  Serial.print(\"\\t\");\n  Serial.println(num2);\n  delay(100);        // 1000 ms delay\n}\n\n/*\n * 1. See the random numbers on the Serial Monitor\n * 2. Open the Serial Plotter\n * 3. Reset ESP32 while looking at the graph\n */"
  },
  {
    "objectID": "tutorials/first-programs.html#floats-functions-conditionals",
    "href": "tutorials/first-programs.html#floats-functions-conditionals",
    "title": "8  First programs",
    "section": "8.4 Floats, functions, conditionals",
    "text": "8.4 Floats, functions, conditionals\nWe will now learn how to deal with floats, how to define our own functions, and how to write conditionals (if/else).\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n// initialize 4 floats (decimals)\n// time and 3 more variables to be plotted\nfloat t = 0, x1 = 0, x2 = 0, x3 = 0;\n\nvoid setup() {\n  // initialize serial communication with computer:\n  Serial.begin(9600);\n}\n\n/*\n * This is how you define a function.\n * In this case, the function returns a float (decimal)\n */\nfloat my_sine(float time) {\n  return sin(time);\n}\n\nfloat my_cosine(float time) {\n  float double_time;              // you can define internal variables,\n  double_time = 2.0 * time;       // write as many commands as you want\n  return 2.0 * cos(double_time);  // in the end, return float\n}\n\nvoid loop() {\n  x1 = my_sine(t);\n  x2 = my_cosine(t);\n  // now let's make a square wave\n  if (x1 &gt; 0) {\n    x3 = -1.0;\n  } else {\n    x3 = 1.0;\n  }\n  Serial.print(\"sin:\"); Serial.print(x1); Serial.print(\"\\t\");\n  Serial.print(\"cos:\"); Serial.print(x2); Serial.print(\"\\t\");\n  Serial.print(\"square:\"); Serial.print(x3);\n  Serial.println();\n  delay(50);        // 1000 ms delay\n  t += 0.05;\n}"
  },
  {
    "objectID": "tutorials/first-programs.html#serial-read",
    "href": "tutorials/first-programs.html#serial-read",
    "title": "8  First programs",
    "section": "8.5 Serial read",
    "text": "8.5 Serial read\nWe can also read data from the Serial Monitor and use it to control the behavior of the ESP32. In this example, the ESP32 waits for you to type a number into the Serial Monitor and then blinks that number of times.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n// serial-read-blink.ino\nString inputString = \"\";\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);\n  Serial.begin(115200);\n  Serial.println(\"Type a number and press Enter:\");\n}\n\nvoid loop() {\n  // check if data is available in the Serial Monitor\n  if (Serial.available()) {\n    inputString = Serial.readStringUntil('\\n');\n    int n = inputString.toInt();  // convert text to integer\n\n    Serial.print(\"Blinking \");\n    Serial.print(n);\n    Serial.println(\" times\");\n\n    for (int i = 0; i &lt; n; i++) {\n      digitalWrite(LED_BUILTIN, HIGH);\n      delay(200);\n      digitalWrite(LED_BUILTIN, LOW);\n      delay(200);\n    }\n\n    Serial.println(\"Done. Type another number:\");\n  }\n}"
  },
  {
    "objectID": "tutorials/first-programs.html#wifi-read-time",
    "href": "tutorials/first-programs.html#wifi-read-time",
    "title": "8  First programs",
    "section": "8.6 WiFi, read time",
    "text": "8.6 WiFi, read time\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n//-----------------------------------------------------------------------------------\n//  WIFI setup:\n\n#include &lt;WiFi.h&gt;\n\nconst char* ssid = \"HUJI-guest\"; // your wifi SSID name\nconst char* password = \"\" ;// wifi pasword\nString formattedTime;\nfloat rand_int = 0, cumulative = 0;\n\nWiFiClient client;\n\n//-------------------------------------------------------------------------------------\n// Set time\n#include &lt;NTPClient.h&gt;\n#include &lt;WiFiUdp.h&gt;\n\nconst long utcOffsetInSeconds = 3600 * 2; // For UTC +2.00 : 2 * 60 * 60\n\nchar daysOfTheWeek[7][12] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n\n// Define NTP Client to get time\nWiFiUDP ntpUDP;\nNTPClient timeClient(ntpUDP, \"pool.ntp.org\", utcOffsetInSeconds);\n\nint time_s ; // variable for the second\n\n\nvoid setup() {\n  Serial.begin(9600);\n  //---------------------------------------------------------------------------\n  //wifi conection:\n  WiFi.disconnect();\n  delay(10);\n  WiFi.begin(ssid, password);\n\n  Serial.println();\n  Serial.println();\n  Serial.print(\"Connecting to \");\n  Serial.println(ssid);\n\n  WiFi.begin(ssid, password);\n\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"NodeMcu connected to wifi...\");\n  Serial.println(ssid);\n  Serial.println();\n  //-----------------------------------------------------------------------\n  // stings for time:\n  timeClient.begin();\n\n}\n\nvoid loop() {\n  timeClient.update();\n  time_s = timeClient.getSeconds();\n  if (time_s == 0) {\n    formattedTime = timeClient.getFormattedTime();\n    Serial.print(\"A new minute has started!\\nFull time = \");\n    Serial.println(formattedTime);\n  }\n  \n  Serial.print(\"second = \");\n  Serial.print(time_s);\n  rand_int = random(10, 20);\n  cumulative += rand_int;\n  Serial.print(\"\\trand = \");\n  Serial.print(rand_int);\n  Serial.print(\"\\trunning sum = \");\n  Serial.println(cumulative);\n  if (time_s%10==9) {\n    Serial.print(\"Average  = \");\n    Serial.println(cumulative / 10);\n    cumulative = 0;\n  }\n  \n  delay(1000);\n}"
  },
  {
    "objectID": "tutorials/first-programs.html#home-assignment",
    "href": "tutorials/first-programs.html#home-assignment",
    "title": "8  First programs",
    "section": "8.7 Home assignment",
    "text": "8.7 Home assignment\nGo to Assignment 1."
  },
  {
    "objectID": "tutorials/electronics-class.html#esp32-to-led",
    "href": "tutorials/electronics-class.html#esp32-to-led",
    "title": "9  Electronics Class",
    "section": "9.1 ESP32 to LED",
    "text": "9.1 ESP32 to LED\n\nGoal: Connect and control an LED using an ESP32 microcontroller.\nDiagram: pin A4 — long leg of LED — short leg of LED — resisistor (330 \\(\\Omega\\)) — GND\n\n\n\nsee diagram\n\n\n\n\n\nsee wiring scheme\n\n\n\nUse the following code to activate LED pin.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nint LED_pin = A4;\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n  // initialize digital pin LED_pin as an output.\n  pinMode(LED_pin, OUTPUT);\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n  digitalWrite(LED_pin, HIGH);   // turn the LED on (HIGH is the voltage level)\n  delay(3000);                       // wait for a second\n  digitalWrite(LED_pin, LOW);    // turn the LED off by making the voltage LOW\n  delay(1000);                       // wait for a second\n}"
  },
  {
    "objectID": "tutorials/electronics-class.html#measuring-voltage-with-a-multimeter",
    "href": "tutorials/electronics-class.html#measuring-voltage-with-a-multimeter",
    "title": "9  Electronics Class",
    "section": "9.2 Measuring Voltage with a Multimeter",
    "text": "9.2 Measuring Voltage with a Multimeter\nTo measure voltage with a multimeter, follow these steps:\n\nSet your multimeter to the DC voltage (V) setting, usually indicated by a straight line and a dashed line beneath it.\nInsert the black probe into the multimeter’s COM port and the red probe into the VΩmA port.\nConnect the black probe to the GND pin on the ESP32 and the red probe to pin A4.\nObserve the voltage reading displayed on the multimeter screen.\n\n\n\nsee wiring scheme"
  },
  {
    "objectID": "tutorials/electronics-class.html#ohms-law",
    "href": "tutorials/electronics-class.html#ohms-law",
    "title": "9  Electronics Class",
    "section": "9.3 Ohm’s Law",
    "text": "9.3 Ohm’s Law\n\n\\[\n\\Delta V = I \\cdot R\n\\]\n\nConcept: Understand the relationship between voltage (V, in volts), current (I, in amperes), and resistance (R, in ohms)."
  },
  {
    "objectID": "tutorials/electronics-class.html#power-supply-setting-and-measuring",
    "href": "tutorials/electronics-class.html#power-supply-setting-and-measuring",
    "title": "9  Electronics Class",
    "section": "9.4 Power Supply: Setting and Measuring",
    "text": "9.4 Power Supply: Setting and Measuring\n\n\nGoal: Understand how to set and measure output from a power supply.\nInstructions: Safely configure voltage and measure output using a multimeter.\n\n\n\nsee wiring scheme"
  },
  {
    "objectID": "tutorials/electronics-class.html#measuring-resistance",
    "href": "tutorials/electronics-class.html#measuring-resistance",
    "title": "9  Electronics Class",
    "section": "9.5 Measuring Resistance",
    "text": "9.5 Measuring Resistance\nResistor Color Code Calculator. Pay attention to the number of bands.\n\nGoal: Measure resistance accurately.\nActivity: Use a multimeter to check the values of different resistors.\n\nTake two different resistors and put them in series and measure the effective resistance.\n\\[\nR_{\\text{series}} = R_1 + R_2\n\\]\n\n\nsee diagram\n\n\n\n\n\nsee wiring scheme\n\n\n\nTake two different resistors and put them in parallel and measure the effective resistance.\n\\[\nR_{\\text{parallel}} = \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)^{-1}\n\\]\n\n\nsee diagram\n\n\n\n\n\nsee wiring scheme"
  },
  {
    "objectID": "tutorials/electronics-class.html#current-measurement",
    "href": "tutorials/electronics-class.html#current-measurement",
    "title": "9  Electronics Class",
    "section": "9.6 Current Measurement",
    "text": "9.6 Current Measurement\n\nGoal: Understand the concept of current and how to measure it.\nActivity: Set up a circuit (one resistor or two resistors in series/parallel) and measure the current flowing through different components. Compare the measurement to what you expect from Ohm’s law."
  },
  {
    "objectID": "tutorials/electronics-class.html#power-in-circuits",
    "href": "tutorials/electronics-class.html#power-in-circuits",
    "title": "9  Electronics Class",
    "section": "9.7 Power in Circuits",
    "text": "9.7 Power in Circuits\n\\[\nP = V \\cdot I\n\\]\nFrom Ohm’s law and the equation for the power, we can derive \\[\nP = I^2 \\cdot R\n\\]\n\\[\nP = \\frac{V^2}{R}\n\\]\n\nConcept: Calculate power (P, in watts) in electrical circuits using the equation above.\nApplication: Get acquainted with the power output of electric components (resistors, LEDs). What happens when the power exceeds their intended value?"
  },
  {
    "objectID": "tutorials/electronics-class.html#led-operation-at-higher-voltage",
    "href": "tutorials/electronics-class.html#led-operation-at-higher-voltage",
    "title": "9  Electronics Class",
    "section": "9.8 LED Operation at Higher Voltage",
    "text": "9.8 LED Operation at Higher Voltage\n\nGoal: Explain LED operation and safely operate it with a 10V power source (using resistors or voltage regulators).\nActivity: Set up a circuit to ensure safe operation of the LED at a higher voltage. Calculate the necessary value of the resistor in this configuration (not 330 \\(\\Omega\\)!)\n\n\n\nsee diagram\n\n\n\n\n\nsee wiring scheme\n\n\n\nSource: Sparkfun \nThe first row in the table indicates how much current your LED will be able to handle continuously. In this case, you can give it 20mA or less, and it will shine its brightest at 20mA. The second row tells us what the maximum peak current should be for short bursts. This LED can handle short bumps to 30mA, but you don’t want to sustain that current for too long. This datasheet is even helpful enough to suggest a stable current range (in the third row from the top) of 16-18mA. That’s a good target number to help you make the resistor calculations we talked about.\nThe following few rows are of less importance for the purposes of this tutorial. The reverse voltage is a diode property that you shouldn’t have to worry about in most cases. The power dissipation is the amount of power in milliWatts that the LED can use before taking damage. This should work itself out as long as you keep the LED within its suggested voltage and current ratings.\n\nThe first row tells us what the forward voltage drop across the LED will be. Forward voltage is a term that will come up a lot when working with LEDs. This number will help you decide how much voltage your circuit will need to supply to the LED. If you have more than one LED connected to a single power source, these numbers are really important because the forward voltage of all of the LEDs added together can’t exceed the supply voltage."
  },
  {
    "objectID": "tutorials/electronics-class.html#potentiometer",
    "href": "tutorials/electronics-class.html#potentiometer",
    "title": "9  Electronics Class",
    "section": "9.9 Potentiometer",
    "text": "9.9 Potentiometer\n\n\nGoal: Introduce variable resistors and their applications.\n\nMeasure the resistance with the multimeter, while twisting the knob.\n\n\nsee diagram\n\n\n\n\n\nsee wiring scheme\n\n\n\nUse a potentiometer to control the brightness of an LED or another output device. Add this potentiometer in series in the circuit you have just built, turn the knob and see what happens.\n\n\nsee diagram\n\n\n\n\n\nsee wiring scheme"
  },
  {
    "objectID": "tutorials/electronics-class-2.html#digital-read",
    "href": "tutorials/electronics-class-2.html#digital-read",
    "title": "10  Electronics Class 2",
    "section": "10.1 Digital read",
    "text": "10.1 Digital read\n\nGoal: Read button press and take an action (flash external LED).\n\nUse the following code.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nconst int buttonPin = A4;        // Pin where the button is connected\nconst int ledPin = D9;   // Pin where the LED is connected\n\n// Variable to store the button state\nint buttonState = 0;\n\nvoid setup() {\n  // Initialize the LED pin as an output\n  pinMode(ledPin, OUTPUT);\n\n  // Initialize the button pin as an input\n  pinMode(buttonPin, INPUT_PULLUP);  // Use the internal pull-up resistor\n  \n  // Start serial communication for debugging (optional)\n  Serial.begin(115200);\n}\n\nvoid loop() {\n  // Read the state of the button\n  buttonState = digitalRead(buttonPin);\n  \n  // Check if the button is pressed\n  if (buttonState == LOW) {  // Assuming the button connects to ground when pressed\n    Serial.println(\"Button pressed! Blinking LED...\");\n    \n    // Blink the LED rapidly for 2 seconds (20 times per second)\n    unsigned long startMillis = millis();\n    while (millis() - startMillis &lt; 2000) { // Run for 2000ms (2 seconds)\n      digitalWrite(ledPin, HIGH);   // Turn the LED on\n      delay(50);                    // Wait for 50ms\n      digitalWrite(ledPin, LOW);    // Turn the LED off\n      delay(50);                    // Wait for 50ms\n    }\n    \n    // Optional: You can add a small delay here to debounce the button\n    delay(200);  // Debounce the button for 200ms\n  }\n\n  // Add a small delay to avoid excessive readings\n  delay(50);\n}\n\n            \n            \n            \n\n\nsee diagram\n\n\n\n\n\nsee wiring scheme"
  },
  {
    "objectID": "tutorials/electronics-class-2.html#reading-an-analog-pin-convert-to-digital-with-built-in-adc",
    "href": "tutorials/electronics-class-2.html#reading-an-analog-pin-convert-to-digital-with-built-in-adc",
    "title": "10  Electronics Class 2",
    "section": "10.2 Reading an Analog Pin, convert to digital with built-in ADC",
    "text": "10.2 Reading an Analog Pin, convert to digital with built-in ADC\nWe will read the signal (middle) pin of the potentiometer, and use the 12-bit built-in Analog to Digital Converter.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nconst int analog_pin = A4; // Pin into which we connect the input voltage\nint val ;  // variable to store the value read\n\n\nvoid setup() {\n  Serial.begin(115200); //\n}\n\nvoid loop() {\n  val = analogRead(analog_pin);  // read the input pin\n  Serial.println(val);          // print value\n  delay(100);\n}\n\n            \n            \n            \n\n\nsee diagram\n\n\n\n\n\nsee wiring scheme\n\n\n\nWhy is the maximum number 4095? What does this have to do with 12-bits?"
  },
  {
    "objectID": "tutorials/electronics-class-2.html#reading-an-analog-pin-convert-to-voltage",
    "href": "tutorials/electronics-class-2.html#reading-an-analog-pin-convert-to-voltage",
    "title": "10  Electronics Class 2",
    "section": "10.3 Reading an Analog Pin, convert to voltage",
    "text": "10.3 Reading an Analog Pin, convert to voltage\nUse the same wiring as above. We will convert bits to volts now: \\(4095 \\text{ bits} = 3.3\\text{ volts}\\).\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nconst int analog_pin = A4; // Pin into which we connect the input voltage\nint val ;  // variable to store the value read\nfloat voltage;\n\nvoid setup() {\n  Serial.begin(115200); //\n}\n\nvoid loop() {\n  val = analogRead(analog_pin);  // read the input pin\n  voltage = (3.3/4095)*val;  // convert to voltage according to ADC\n  Serial.print(\"Voltage: \");\n  Serial.print(voltage);          // print value\n  Serial.println(\" V\");\n  delay(100);\n}"
  },
  {
    "objectID": "tutorials/electronics-class-2.html#pwm-with-esp32",
    "href": "tutorials/electronics-class-2.html#pwm-with-esp32",
    "title": "10  Electronics Class 2",
    "section": "10.4 PWM with ESP32",
    "text": "10.4 PWM with ESP32\nPulse-width modulation (PWM) is a method of controlling the average power delivered by an electrical signal. The average value of voltage (and current) fed to the load is controlled by switching the supply between 0 and 100% at a rate faster than it takes the load to change significantly. PWM is a technique for getting analog results with digital means. Digital control is used to create a square wave, a signal switched between on and off. This on-off pattern can simulate voltages in between the full Vcc of the board and off by changing the portion of time the signal spends on versus the time that the signal spends off. PWM is used in many applications such as controlling motor speed, heat output of heaters and variable speed fan controllers.\n\nUse the following code to activate LED pin with PWM, using the potentiometer as input.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nconst int ledPin = D9; // the number of the LED pin\nint analog_pin = A4; // Pin into which we connect the middle leg of the potentiometer\nint val ;  // variable to store the value read\n\n// setting PWM properties\nconst int freq = 5000;        // 5000 Hz\nconst int ledChannel = 0;\nconst int resolution = 12;    // 12-bit resolution = between 0 and 4095\n \nvoid setup(){\n  Serial.begin(115200);\n    \n  // configure LED PWM functionalitites\n  ledcSetup(ledChannel, freq, resolution);\n  \n  // attach the channel to the GPIO to be controlled\n  ledcAttachPin(ledPin, ledChannel);\n}\n \nvoid loop(){\n    val = analogRead(analog_pin);  // read the input pin\n    Serial.println(val);          // print value\n    ledcWrite(ledChannel, val);\n    delay(15);  // update duty cycle parameters every 15 ms\n  }\n\n            \n            \n            \n\n\nsee diagram\n\n\n\n\n\nsee wiring scheme"
  },
  {
    "objectID": "tutorials/control.html#pwm-with-esp32",
    "href": "tutorials/control.html#pwm-with-esp32",
    "title": "11  Control",
    "section": "11.1 PWM with ESP32",
    "text": "11.1 PWM with ESP32\nPulse-width modulation (PWM) is a method of controlling the average power delivered by an electrical signal. The average value of voltage (and current) fed to the load is controlled by switching the supply between 0 and 100% at a rate faster than it takes the load to change significantly. PWM is a technique for getting analog results with digital means. Digital control is used to create a square wave, a signal switched between on and off. This on-off pattern can simulate voltages in between the full Vcc of the board and off by changing the portion of time the signal spends on versus the time that the signal spends off. PWM is used in many applications such as controlling motor speed, heat output of heaters and variable speed fan controllers.\n\nUse the following code to activate LED pin with PWM.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n/*\n  Rui Santos & Sara Santos - Random Nerd Tutorials\n  Complete project details at https://RandomNerdTutorials.com/esp32-pwm-arduino-ide/\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files.  \n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n*/\n\n// the number of the LED pin\nconst int ledPin = D9;  // 16 corresponds to GPIO 16\n\nvoid setup() {\n  // set the LED as an output\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop(){\n  // increase the LED brightness\n  for(int dutyCycle = 0; dutyCycle &lt;= 255; dutyCycle++){   \n    // changing the LED brightness with PWM\n    analogWrite(ledPin, dutyCycle);\n    delay(15);\n  }\n\n  // decrease the LED brightness\n  for(int dutyCycle = 255; dutyCycle &gt;= 0; dutyCycle--){\n    // changing the LED brightness with PWM\n    analogWrite(ledPin, dutyCycle);\n    delay(15);\n  }\n}\n\n            \n            \n            \n If for some reason you are working with an older version of ESP32 board manager (2.0.17 or lower), then use the code below. If you have no idea what I’m talking about, just ignore this.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n// the number of the LED pin\nconst int ledPin = D9;\n\n// setting PWM properties\nconst int freq = 5000;\nconst int ledChannel = 0;\nconst int resolution = 8;\n \nvoid setup(){\n  // configure LED PWM functionalitites\n  ledcSetup(ledChannel, freq, resolution);\n  \n  // attach the channel to the GPIO to be controlled\n  ledcAttachPin(ledPin, ledChannel);\n}\n \nvoid loop(){\n  // increase the LED brightness\n  for(int dutyCycle = 0; dutyCycle &lt;= 255; dutyCycle++){   \n    // changing the LED brightness with PWM\n    ledcWrite(ledChannel, dutyCycle);\n    delay(15);\n  }\n\n  // decrease the LED brightness\n  for(int dutyCycle = 255; dutyCycle &gt;= 0; dutyCycle--){\n    // changing the LED brightness with PWM\n    ledcWrite(ledChannel, dutyCycle);   \n    delay(15);\n  }\n}"
  },
  {
    "objectID": "tutorials/control.html#relay",
    "href": "tutorials/control.html#relay",
    "title": "11  Control",
    "section": "11.2 Relay",
    "text": "11.2 Relay\n\nA relay is an electromagnetic switch that opens and closes circuits electromechanically or electronically. A relatively small electric current that can turn on or off a much larger electric current operates a relay.\nThe right side in the image above has a set of four pins and a set of three pins. The top set consists of:\n\nVCC should be connected to the ESP32 VCC (5 volts)\nGND connects to the ESP32 GND.\nIN1 and IN2 are input pins, used to control the bottom and top relays, respectively, and should be connected to a GPIO pin in the ESP32.\n\nThe terminals on the left are connected to the load, the equipment that consumes power. The signal you send to the IN pins determines whether the relay is active or not. The relay is triggered when the input goes below about 2V. This means that you’ll have the following scenarios:\n\nNormally Closed (NC) configuration:\n\nHIGH signal – current is flowing\nLOW signal – current is not flowing\n\nNormally Open (NO) configuration:\n\nHIGH signal – current is not flowing\nLOW signal – current is flowing\n\n\nWhether you use the NC or NO configuration, you should always connect one of them to the COM (common) terminal.\nYou should use a normally closed configuration when the current should be flowing most of the time, and you only want to stop it occasionally.\nUse a normally open configuration when you want the current to flow occasionally (for example, to turn on a lamp occasionally).\n\nThe other set of three pins (on the left in the figure above) are GND, VCC, and JD-VCC. The JD-VCC pin powers the electromagnet of the relay. Notice that the module has a jumper cap connecting the VCC and JD-VCC pins; the one shown here is yellow, but yours may be a different color.\nWith the jumper cap on, the VCC and JD-VCC pins are connected. That means the relay electromagnet is directly powered from the ESP32 power pin, so the relay module and the ESP32 circuits are not physically isolated from each other.\nWithout the jumper cap, you need to provide an independent power source to power up the relay’s electromagnet through the JD-VCC pin. That configuration physically isolates the relays from the ESP32 with the module’s built-in optocoupler, which prevents damage to the ESP32 in case of electrical spikes.\n\nThe figure above shows in a very simple way that the relay behaves like a switch with respect to the top circuit.\n\nYou should NOT build the above circuit, since it is a high voltage circuit (220 V). In class we will use 5, 12 or 24 volts.\n\nLet’s make an LED blink, but now using a relay. The code below is the same you used to make the LED blink, when it got its energy from pin A4. This time, we will use A4 to signal the relay to open or close the circuit.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nint LED_pin = A4;\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n  // initialize digital pin LED_pin as an output.\n  pinMode(LED_pin, OUTPUT);\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n  digitalWrite(LED_pin, HIGH);   // turn the LED on (HIGH is the voltage level)\n  delay(3000);                       // wait for a second\n  digitalWrite(LED_pin, LOW);    // turn the LED off by making the voltage LOW\n  delay(1000);                       // wait for a second\n}\n\n            \n            \n            \n\n\nsee diagram\n\n\n\n\n\nsee wiring scheme"
  },
  {
    "objectID": "tutorials/control.html#sht31-sensor",
    "href": "tutorials/control.html#sht31-sensor",
    "title": "11  Control",
    "section": "11.3 SHT31 Sensor",
    "text": "11.3 SHT31 Sensor\nThe SHT31 is a high-precision temperature and humidity sensor that can be used in a wide range of applications. It measures temperature and humidity using a capacitive humidity sensor and a band-gap temperature sensor. It has a wide measurement range of -40°C to 125°C for temperature and 0-100% for relative humidity. The SHT31 is a digital sensor, which means it communicates with the microcontroller over a digital interface. See more details on the Adafruit’s github page for the SHT31 and full specs on the SHT31 datasheet.\n\n11.3.1 Libraries\nTo use the SHT31 sensor with an ESP32 microcontroller, we will need to use the Adafruit_SHT31 library. This library is specifically designed to work with the SHT31 sensor and makes it easy to read temperature and humidity values from the sensor.\nTo install the library, follow these steps:\n\nOpen the Arduino IDE\nGo to Sketch &gt; Include Library &gt; Manage Libraries\nSearch for “Adafruit_SHT31” and click the Install button\nWait for the library to install\n\n\n\n11.3.2 Wiring\nTo connect the SHT31 sensor to the ESP32 microcontroller, we will need to use four wires: VCC, GND, SDA, and SCL. Here is a table that shows how to connect the wires:\n\n\n\nSHT31 Pin\nESP32 Pin\n\n\n\n\nVCC\n3V3\n\n\nGND\nGND\n\n\nSDA\nGPIO21\n\n\nSCL\nGPIO22\n\n\n\nNote: The ESP32’s 3V3 pin provides 3.3 volts of power, which is the correct voltage for the SHT31 sensor. Do not use the 5V pin, as it will damage the sensor.\n\n\n11.3.3 Code\nHere is the code for reading temperature and humidity values from the SHT31 sensor.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n/*\n * This program is a modification of\n * http://www.esp32learning.com/code/esp32-and-sht31-sensor-example.php\n */\n#include &lt;Arduino.h&gt;   // Include the Arduino library\n#include &lt;Wire.h&gt;      // Include the Wire library for I2C communication\n#include \"Adafruit_SHT31.h\" // Include the SHT31 library from Adafruit\n\nAdafruit_SHT31 sht31 = Adafruit_SHT31(); // Create an instance of the SHT31 object\n\nvoid setup() {\n  Serial.begin(115200);        // Initialize the serial communication with a baud rate of 112500\n  if (! sht31.begin(0x44)) {   // Check if SHT31 is connected and start it with address 0x44\n    // Print an error message if SHT31 is not found\n    Serial.println(\"Couldn't find SHT31\");\n    while (1) delay(1);  // Wait indefinitely\n  }\n}\n\nvoid loop() {\n  // Read temperature from SHT31 and assign it to \"temperature\"\n  float temperature = sht31.readTemperature(); \n  // Read relative humidity from SHT31 and assign it to \"humidity\"\n  float humidity = sht31.readHumidity();\n\n  if (! isnan(temperature)) {     // Check if t is not NaN (not a number)\n    Serial.print(\"temp_deg_C:\");  // Print temperature label\n    Serial.print(temperature);    // Print temperature value\n    Serial.print(\"\\t\");           // Write a tab space\n  } \n  else {\n    // Print an error message if temperature reading fails\n    Serial.println(\"Failed to read temperature\");\n  }\n\n  if (! isnan(humidity)) {        // Check if h is not NaN (not a number)\n    Serial.print(\"rel_hum_%:\");   // Print humidity label\n    Serial.print(humidity);       // Print humidity value\n  } \n  else {\n    // Print an error message if humidity reading fails\n    Serial.println(\"Failed to read humidity\");\n  }\n\n  Serial.println();    // Break line\n  delay(1000);         // Wait 1 second\n}"
  },
  {
    "objectID": "tutorials/control.html#challenges",
    "href": "tutorials/control.html#challenges",
    "title": "11  Control",
    "section": "11.4 Challenges",
    "text": "11.4 Challenges\n\n11.4.1 High temperature activates fan\nYou will receive a low-voltage fan. Build a control system that turns the fan on if temperature goes above a given threshold, e.g. 30 °C.\n\n\n11.4.2 Traffic lights\nUsing red, orange and green LEDs, build a traffic light system that responds to temperature:\n\nred turns on if \\(T&gt;30\\) °C\norange turns on if \\(27&lt;T&lt;30\\) °C\ngreen turns on if \\(T&lt;27\\) °C\n\n\n\n11.4.3 Bonus\nBuild an PMW-based control system where the duty cycle tempends on temperature."
  },
  {
    "objectID": "tutorials/control.html#extra-codes-and-examples",
    "href": "tutorials/control.html#extra-codes-and-examples",
    "title": "11  Control",
    "section": "11.5 Extra codes and examples",
    "text": "11.5 Extra codes and examples\n\n11.5.1 Serial read and blink\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n// Define the built-in LED pin\n#define LED_PIN LED_BUILTIN  // Most ESP32 boards use GPIO 2 for the built-in LED\n\nvoid setup() {\n  // Initialize serial communication at 115200 baud\n  Serial.begin(115200);\n  \n  // Wait for the serial monitor to connect\n  while (!Serial) {\n    ; // Wait for serial port to connect. Needed for native USB port only\n  }\n  \n  // Set the LED pin as an output\n  pinMode(LED_PIN, OUTPUT);\n  \n  // Print instructions\n  Serial.println(\"Enter the number of times you want the LED to blink:\");\n}\n\nvoid loop() {\n  // Check if data is available to read\n  if (Serial.available() &gt; 0) {\n    // Read the integer from the serial monitor\n    int blinkCount = Serial.parseInt();\n    \n    // Check if the parsed integer is greater than 0\n    if (blinkCount &gt; 0) {\n      // Print the received number\n      Serial.print(\"Blinking LED \");\n      Serial.print(blinkCount);\n      Serial.println(\" times\");\n      \n      // Blink the LED the specified number of times\n      for (int i = 0; i &lt; blinkCount; i++) {\n        digitalWrite(LED_PIN, HIGH);  // Turn on the LED\n        delay(500);                   // Wait for 500 milliseconds\n        digitalWrite(LED_PIN, LOW);   // Turn off the LED\n        delay(500);                   // Wait for 500 milliseconds\n      }\n      \n      // Print done message\n      Serial.println(\"Done blinking\");\n    }\n  }\n}"
  },
  {
    "objectID": "tutorials/digital-read-write.html#turn-on-led-upon-button-press",
    "href": "tutorials/digital-read-write.html#turn-on-led-upon-button-press",
    "title": "12  Reading digital and analog",
    "section": "12.1 Turn on LED upon button press",
    "text": "12.1 Turn on LED upon button press\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n// Define the pin numbers\nconst int buttonPin = D4;\nconst int ledPin = A4;\n\nvoid setup() {\n  // Set the pin modes\n  pinMode(buttonPin, INPUT_PULLUP);\n  pinMode(ledPin, OUTPUT);\n\n  // Initialize Serial communication\n  Serial.begin(115200);\n}\n\nvoid loop() {\n  // Read the state of the button\n  int buttonState = digitalRead(buttonPin);\n\n  // If the button is not pressed (pin is pulled high)\n  if (buttonState == HIGH) {\n    // Turn on the LED\n    digitalWrite(ledPin, LOW);\n\n    // Print the button state to the Serial Monitor\n    Serial.println(\"Button is not pressed.\");\n  } else {\n    // Turn off the LED\n    digitalWrite(ledPin, HIGH);\n\n    // Print the button state to the Serial Monitor\n    Serial.println(\"Button is pressed.\");\n  }\n\n  // Delay for a short period to debounce the button\n  delay(50);\n}"
  },
  {
    "objectID": "tutorials/digital-read-write.html#toggle-led-upon-button-press",
    "href": "tutorials/digital-read-write.html#toggle-led-upon-button-press",
    "title": "12  Reading digital and analog",
    "section": "12.2 Toggle LED upon button press",
    "text": "12.2 Toggle LED upon button press\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n// Define the pin numbers\nconst int buttonPin = D4;\nconst int ledPin = A4;\n\n// Initialize the LED state to off\nbool ledState = false;\n\nvoid setup() {\n  // Set the pin modes\n  pinMode(buttonPin, INPUT_PULLUP);\n  pinMode(ledPin, OUTPUT);\n\n  // Initialize Serial communication\n  Serial.begin(115200);\n}\n\nvoid loop() {\n  // Read the state of the button\n  int buttonState = digitalRead(buttonPin);\n\n  // If the button is pressed\n  if (buttonState == LOW) {\n    // Toggle the LED state\n    ledState = !ledState;\n    digitalWrite(ledPin, ledState);\n\n    // Print the LED state to the Serial Monitor\n    if (ledState) {\n      Serial.println(\"LED is on.\");\n    } else {\n      Serial.println(\"LED is off.\");\n    }\n\n    // Wait a short period to debounce the button\n    delay(500);\n  }\n}"
  },
  {
    "objectID": "tutorials/digital-read-write.html#digital-read",
    "href": "tutorials/digital-read-write.html#digital-read",
    "title": "12  Reading digital and analog",
    "section": "12.3 Digital read",
    "text": "12.3 Digital read\n\nGoal: Read button press and take an action (flash external LED).\n\nUse the following code.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nconst int buttonPin = A4;        // Pin where the button is connected\nconst int ledPin = D9;   // Pin where the LED is connected\n\n// Variable to store the button state\nint buttonState = 0;\n\nvoid setup() {\n  // Initialize the LED pin as an output\n  pinMode(ledPin, OUTPUT);\n\n  // Initialize the button pin as an input\n  pinMode(buttonPin, INPUT_PULLUP);  // Use the internal pull-up resistor\n  \n  // Start serial communication for debugging (optional)\n  Serial.begin(115200);\n}\n\nvoid loop() {\n  // Read the state of the button\n  buttonState = digitalRead(buttonPin);\n  \n  // Check if the button is pressed\n  if (buttonState == LOW) {  // Assuming the button connects to ground when pressed\n    Serial.println(\"Button pressed! Blinking LED...\");\n    \n    // Blink the LED rapidly for 2 seconds (20 times per second)\n    unsigned long startMillis = millis();\n    while (millis() - startMillis &lt; 2000) { // Run for 2000ms (2 seconds)\n      digitalWrite(ledPin, HIGH);   // Turn the LED on\n      delay(50);                    // Wait for 50ms\n      digitalWrite(ledPin, LOW);    // Turn the LED off\n      delay(50);                    // Wait for 50ms\n    }\n    \n    // Optional: You can add a small delay here to debounce the button\n    delay(200);  // Debounce the button for 200ms\n  }\n\n  // Add a small delay to avoid excessive readings\n  delay(50);\n}\n\n            \n            \n            \n\n\nsee diagram\n\n\n\n\n\nsee wiring scheme"
  },
  {
    "objectID": "tutorials/digital-read-write.html#touch-sensor",
    "href": "tutorials/digital-read-write.html#touch-sensor",
    "title": "12  Reading digital and analog",
    "section": "12.4 Touch sensor",
    "text": "12.4 Touch sensor\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n#include &lt;Arduino.h&gt;\n\n// Define the touch sensor pin\n#define TOUCH_PIN D12  // You can change this to another touch pin if needed\n\nvoid setup() {\n  // Initialize serial communication at 115200 baud\n  Serial.begin(115200);\n  \n  // Wait for the serial monitor to connect\n  while (!Serial) {\n    ; // Wait for serial port to connect. Needed for native USB port only\n  }\n}\n\nvoid loop() {\n  // Read the value from the touch sensor\n  int touchValue = touchRead(TOUCH_PIN);\n\n  // Print the touch sensor value\n  Serial.print(\"Touch value: \");\n  Serial.println(touchValue);\n  \n  // Check if the touch sensor is activated (value will be lower when touched)\n  if (touchValue &lt; 30) {  // You might need to adjust this threshold value\n    Serial.println(\"Touch detected!\");\n  }\n\n  // Add a small delay to avoid spamming the serial monitor\n  delay(100);\n}"
  },
  {
    "objectID": "tutorials/digital-read-write.html#control-led-with-touch-sensor",
    "href": "tutorials/digital-read-write.html#control-led-with-touch-sensor",
    "title": "12  Reading digital and analog",
    "section": "12.5 Control LED with touch sensor",
    "text": "12.5 Control LED with touch sensor\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n#include &lt;Arduino.h&gt;\n\n// Define the touch sensor pin\n#define TOUCH_PIN T0  // You can change this to another touch pin if needed\n\n// Define the built-in LED pin\n#define LED_PIN LED_BUILTIN  // Most ESP32 boards use GPIO 2 for the built-in LED\n\nvoid setup() {\n  // Initialize serial communication at 115200 baud\n  Serial.begin(115200);\n  \n  // Wait for the serial monitor to connect\n  while (!Serial) {\n    ; // Wait for serial port to connect. Needed for native USB port only\n  }\n\n  // Set the LED pin as an output\n  pinMode(LED_PIN, OUTPUT);\n}\n\nvoid loop() {\n  // Read the value from the touch sensor\n  int touchValue = touchRead(TOUCH_PIN);\n\n  // Print the touch sensor value\n  Serial.print(\"Touch value: \");\n  Serial.println(touchValue);\n  \n  // Check if the touch sensor is activated (value will be lower when touched)\n  if (touchValue &lt; 30) {  // You might need to adjust this threshold value\n    Serial.println(\"Touch detected!\");\n    digitalWrite(LED_PIN, HIGH);  // Turn on the LED\n  } else {\n    digitalWrite(LED_PIN, LOW);  // Turn off the LED\n  }\n\n  // Add a small delay to avoid spamming the serial monitor\n  delay(100);\n}"
  },
  {
    "objectID": "tutorials/digital-read-write.html#reading-an-analog-pin-convert-to-digital-with-built-in-adc",
    "href": "tutorials/digital-read-write.html#reading-an-analog-pin-convert-to-digital-with-built-in-adc",
    "title": "12  Reading digital and analog",
    "section": "12.6 Reading an Analog Pin, convert to digital with built-in ADC",
    "text": "12.6 Reading an Analog Pin, convert to digital with built-in ADC\nWe will read the signal (middle) pin of the potentiometer, and use the 12-bit built-in Analog to Digital Converter.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nconst int analog_pin = A4; // Pin into which we connect the input voltage\nint val ;  // variable to store the value read\n\n\nvoid setup() {\n  Serial.begin(115200); //\n}\n\nvoid loop() {\n  val = analogRead(analog_pin);  // read the input pin\n  Serial.println(val);          // print value\n  delay(100);\n}\n\n            \n            \n            \n\n\nsee diagram\n\n\n\n\n\nsee wiring scheme\n\n\n\nWhy is the maximum number 4095? What does this have to do with 12-bits?"
  },
  {
    "objectID": "tutorials/digital-read-write.html#reading-an-analog-pin-convert-to-voltage",
    "href": "tutorials/digital-read-write.html#reading-an-analog-pin-convert-to-voltage",
    "title": "12  Reading digital and analog",
    "section": "12.7 Reading an Analog Pin, convert to voltage",
    "text": "12.7 Reading an Analog Pin, convert to voltage\nUse the same wiring as above. We will convert bits to volts now: \\(4095 \\text{ bits} = 3.3\\text{ volts}\\).\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nconst int analog_pin = A4; // Pin into which we connect the input voltage\nint val ;  // variable to store the value read\nfloat voltage;\n\nvoid setup() {\n  Serial.begin(115200); //\n}\n\nvoid loop() {\n  val = analogRead(analog_pin);  // read the input pin\n  voltage = (3.3/4095)*val;  // convert to voltage according to ADC\n  Serial.print(\"Voltage: \");\n  Serial.print(voltage);          // print value\n  Serial.println(\" V\");\n  delay(100);\n}"
  },
  {
    "objectID": "tutorials/digital-read-write.html#reading-potentiometer-with-analog-pin-convert-to-angle",
    "href": "tutorials/digital-read-write.html#reading-potentiometer-with-analog-pin-convert-to-angle",
    "title": "12  Reading digital and analog",
    "section": "12.8 Reading Potentiometer with Analog Pin, convert to angle",
    "text": "12.8 Reading Potentiometer with Analog Pin, convert to angle\nPut a piece of cardboard in your potentiometer’s slit. Your goal is to build a calibration curve, that is, a function that converts reading from something you don’t care about (increments from 0 to 4095) to something that you do care about (angle).\nThe simplest thing you can do is to measure the increments (\\(i\\)) that you get for two given angles (say, \\(\\theta\\) equals zero and 90 degrees). Let’s say you measured \\((i_1,\\theta_1)\\) and \\((i_2,\\theta_2)\\). If the potentiometer is linear, we will get a linear relationship between angle and increment:\n\\[\n\\theta = a i + b\n\\]\nSubstitute these two points in the equation above:\n\\[\n\\theta_1 = a i_1 + b\n\\tag{12.1}\\]\n\\[\n\\theta_2 = a i_2 + b\n\\tag{12.2}\\]\nNow let’s subtract Equation 12.3 from Equation 12.1:\n\\[\n\\theta_1 - \\theta_2 = a (i_1 - i_2)\n\\tag{12.3}\\]\nNow solve for the slope \\(a\\):\n\\[\na = (\\theta_1 - \\theta_2) / (i_1 - i_2)\n\\tag{12.4}\\]\nTo find the intercept \\(b\\), just substitute \\(a\\) into Equation 12.1 and solve for \\(b\\):\n\\[\nb = \\theta_1 - a i_1\n\\tag{12.5}\\]\nput the lines below in the code we ran before, they are not in the correct place, it is here just so you have an idea how to update the previous code.\nfloat angle, increment, a, b;\n\na = 12345;  // put here what you calculated\nb = 12345;  // put here what you calculated\n\nincrement = analogRead(analog_pin);\nangle = a * increment + b;"
  },
  {
    "objectID": "tutorials/digital-read-write.html#voltage-divider",
    "href": "tutorials/digital-read-write.html#voltage-divider",
    "title": "12  Reading digital and analog",
    "section": "12.9 Voltage divider",
    "text": "12.9 Voltage divider\nMany sensors have calibration curves that relate their resistance changes to the measured variable. For example, the resistance of photoresistors and thermistors changes with light and temperature, respectively. To handle this, we need to understand Voltage Dividers.\n\nCheck out this great tutorial\nHow to derive the equation for the voltage divider?\nFirst, write Ohm’s law for the two components in series:\n\\[\nV_{in} = (R_1 + R_2) I\n\\tag{12.6}\\]\nNow write Ohm’s law just for the second component\n\\[\nV_{out} = R_2 I\n\\tag{12.7}\\]\nNow solve Equation 12.7 for \\(I\\)\n\\[\nI = \\frac{V_{out}}{R_2}\n\\tag{12.8}\\]\n… and substitute it into Equation 12.6:\n\\[\nV_{in} = (R_1 + R_2) \\frac{V_{out}}{R_2}\n\\tag{12.9}\\]\nSolving for \\(V_{out}\\) yields the famous equation for the voltage divider:\n\\[\nV_{out} = \\frac{R_2}{R_1 + R_2} V_{in}\n\\tag{12.10}\\]\nWe usually need to find the value of the resistance \\(R_2\\):\n\\[\nR_2 = \\frac{V_{in} - V_{out}}{V_{out}} R_2\n\\]"
  },
  {
    "objectID": "tutorials/digital-read-write.html#photoresistor",
    "href": "tutorials/digital-read-write.html#photoresistor",
    "title": "12  Reading digital and analog",
    "section": "12.10 Photoresistor",
    "text": "12.10 Photoresistor\n \nPlay with your photoresistor. Measure its resistance when it receives bright light and when it doesn’t receive any light at all. This will give you an idea of what value of resistor to use together with your photoresistor when building your voltage divider. Build the following circuit:\n3V3 → resistor → * photoresistor → GND\nConnect pin A4 to the asterisk, this is your \\(V_\\text{out}\\) in the voltage divider.\n\nWe will read the increments from the photoresistor, using a code from before:\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nconst int analog_pin = A4; // Pin into which we connect the input voltage\nint val ;  // variable to store the value read\n\n\nvoid setup() {\n  Serial.begin(115200); //\n}\n\nvoid loop() {\n  val = analogRead(analog_pin);  // read the input pin\n  Serial.println(val);          // print value\n  delay(100);\n}"
  },
  {
    "objectID": "tutorials/digital-read-write.html#thermistor",
    "href": "tutorials/digital-read-write.html#thermistor",
    "title": "12  Reading digital and analog",
    "section": "12.11 Thermistor",
    "text": "12.11 Thermistor\n \n\nModel equations and calculator of constants for thermistors\nThermistor tutorial\n\n \nWe will use the \\(\\beta\\) model\n\\[\nR = R_{25} \\exp\\left[ \\beta \\left(\\frac{1}{T} - \\frac{1}{298.15} \\right) \\right],\n\\]\nwhere\n\n\\(R\\) is given in ohms,\n\\(R_{25}\\) is the resistance for 25 °C,\n\\(T\\) is temperature in Kelvin.\n\nOf course, we want the temperature (°C) as a function of the resistance:\n\\[\nT = \\left[ \\frac{1}{\\beta} \\ln\\left(\\frac{R}{R_{25}}\\right) + \\frac{1}{298.15} \\right]^{-1} - 273.15\n\\]\n\nFor our thermistor, \\[\n\\beta = 4150\n\\]\n\nDownload Data Sheet\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n// Thermistor \n// reading the temperature via the ESP32's ADC\n\nconst int analog_pin = A4; // Pin into which we connect the input voltage\nint val ;  // variable to store the value read\nfloat v2; // variable to store the voltage of v2\nint r1 = 10000; // R1 value (in the voltage divider)\nfloat v1 = 3.3; // V1 value\nint b_val = 4150; // B value of the resistor (from the data sheet)\nfloat r2; // variable to store the resistance of r2 (thermistor resistance)\nfloat t; // variable to store the temperature\nint adc_steps = 4095; // the number of increments our ADC has (ESP32 = 12bit)\nfloat r_25 = 10000; // the thermistor resistance at 25C (from the data sheet)\n\n// function to convert resistance to temperature according to the b value\n// equation in this link:\n// https://www.thinksrs.com/downloads/programs/therm%20calc/ntccalibrator/ntccalculator.html\nfloat resistance_to_temperature(int b, float r, float r_25) {\n  return b/(log(r/r_25)+(b/298.15))-273.15;\n}\n\nvoid setup() {\n  Serial.begin(115200); //\n}\n\nvoid loop() {\n  val = analogRead(analog_pin);  // read the input pin (reading v2)\n  v2 = (v1/adc_steps)*val;  // convert to voltage of v2 according to ADC\n  r2 = (v2*r1)/(v1-v2);\n  t = resistance_to_temperature(b_val, r2, r_25);\n  Serial.print(\"Temperature: \");\n  Serial.print(t);          // print temperature\n  Serial.println(\" C\");\n  delay(100);\n}"
  },
  {
    "objectID": "tutorials/digital-sensors.html#sht31-temperature-humidity-sensor-using-i2c-communication",
    "href": "tutorials/digital-sensors.html#sht31-temperature-humidity-sensor-using-i2c-communication",
    "title": "13  Digital sensors",
    "section": "13.1 SHT31 Temperature & Humidity Sensor Using I2C communication",
    "text": "13.1 SHT31 Temperature & Humidity Sensor Using I2C communication\nIn this tutorial you can find a lot more information.\nCode for reading the sensor:\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n/*\n * This program is a modification of\n * http://www.esp32learning.com/code/esp32-and-sht31-sensor-example.php\n */\n#include &lt;Arduino.h&gt;   // Include the Arduino library\n#include &lt;Wire.h&gt;      // Include the Wire library for I2C communication\n#include \"Adafruit_SHT31.h\" // Include the SHT31 library from Adafruit\n\nAdafruit_SHT31 sht31 = Adafruit_SHT31(); // Create an instance of the SHT31 object\n\nvoid setup() {\n  Serial.begin(115200);        // Initialize the serial communication with a baud rate of 112500\n  if (! sht31.begin(0x44)) {   // Check if SHT31 is connected and start it with address 0x44\n    // Print an error message if SHT31 is not found\n    Serial.println(\"Couldn't find SHT31\");\n    while (1) delay(1);  // Wait indefinitely\n  }\n}\n\nvoid loop() {\n  // Read temperature from SHT31 and assign it to \"temperature\"\n  float temperature = sht31.readTemperature(); \n  // Read relative humidity from SHT31 and assign it to \"humidity\"\n  float humidity = sht31.readHumidity();\n\n  if (! isnan(temperature)) {     // Check if t is not NaN (not a number)\n    Serial.print(\"temp_deg_C:\");  // Print temperature label\n    Serial.print(temperature);    // Print temperature value\n    Serial.print(\"\\t\");           // Write a tab space\n  } \n  else {\n    // Print an error message if temperature reading fails\n    Serial.println(\"Failed to read temperature\");\n  }\n\n  if (! isnan(humidity)) {        // Check if h is not NaN (not a number)\n    Serial.print(\"rel_hum_%:\");   // Print humidity label\n    Serial.print(humidity);       // Print humidity value\n  } \n  else {\n    // Print an error message if humidity reading fails\n    Serial.println(\"Failed to read humidity\");\n  }\n\n  Serial.println();    // Break line\n  delay(1000);         // Wait 1 second\n}"
  },
  {
    "objectID": "tutorials/digital-sensors.html#vl53l0x-time-of-flight-distance-sensor-using-i2c-communication",
    "href": "tutorials/digital-sensors.html#vl53l0x-time-of-flight-distance-sensor-using-i2c-communication",
    "title": "13  Digital sensors",
    "section": "13.2 VL53L0X Time-of-Flight Distance Sensor Using I2C communication",
    "text": "13.2 VL53L0X Time-of-Flight Distance Sensor Using I2C communication\nIn this tutorial you can find a lot more information.\nCode for reading the sensor:\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n#include \"Adafruit_VL53L0X.h\"\n\n// also on http://www.esp32learning.com/code/vl53l0x-time-of-flight-sensor-and-esp32.php\nAdafruit_VL53L0X lox = Adafruit_VL53L0X();\n\nvoid setup() {\n  Serial.begin(115200);\n\n  // wait until serial port opens for native USB devices\n  while (! Serial) {\n    delay(1);\n  }\n  \n  Serial.println(\"Adafruit VL53L0X test\");\n  if (!lox.begin()) {\n    Serial.println(F(\"Failed to boot VL53L0X\"));\n    while(1);\n  }\n  // power \n  Serial.println(F(\"VL53L0X API Simple Ranging example\\n\\n\")); \n}\n\n\nvoid loop() {\n  VL53L0X_RangingMeasurementData_t measure;\n    \n  Serial.print(\"Reading a measurement... \");\n  lox.rangingTest(&measure, false); // pass in 'true' to get debug data printout!\n\n  if (measure.RangeStatus != 4) {  // phase failures have incorrect data\n    Serial.print(\"Distance (mm): \"); Serial.println(measure.RangeMilliMeter);\n  } else {\n    Serial.println(\" out of range \");\n  }\n    \n  delay(100);\n}"
  },
  {
    "objectID": "tutorials/digital-sensors.html#ds18b20-temperature-sensor",
    "href": "tutorials/digital-sensors.html#ds18b20-temperature-sensor",
    "title": "13  Digital sensors",
    "section": "13.3 DS18B20 Temperature Sensor",
    "text": "13.3 DS18B20 Temperature Sensor\nPretty accurate temperature sensor. Each sensor has its own unique address, enabling the connection of numerous sensors to only on pin on the Arduino/ESP32.\nIn this tutorial you can find a lot more information.\nCode for finding the sensor’s address:\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n/*\n * Rui Santos \n * Complete Project Details https://randomnerdtutorials.com\n */\n\n#include &lt;OneWire.h&gt;\n\n// Based on the OneWire library example\n\nOneWire ds(4);  //data wire connected to GPIO 4\n\nvoid setup(void) {\n  Serial.begin(115200);\n}\n\nvoid loop(void) {\n  byte i;\n  byte addr[8];\n  \n  if (!ds.search(addr)) {\n    Serial.println(\" No more addresses.\");\n    Serial.println();\n    ds.reset_search();\n    delay(250);\n    return;\n  }\n  Serial.print(\" ROM =\");\n  for (i = 0; i &lt; 8; i++) {\n    Serial.write(' ');\n    Serial.print(addr[i], HEX);\n  }\n}"
  },
  {
    "objectID": "tutorials/cloud-connectivity.html#thingspeak",
    "href": "tutorials/cloud-connectivity.html#thingspeak",
    "title": "14  Cloud connectivity",
    "section": "14.1 ThingSpeak",
    "text": "14.1 ThingSpeak\nThingSpeak is an open-source Internet of Things (IoT) platform that allows users to collect, analyze, and act on data from sensors or devices. It is a useful tool for monitoring and controlling devices in real-time, and it is commonly used in research projects, industrial automation, and smart homes. In this tutorial, we will introduce the basic concepts of ThingSpeak and demonstrate how to use it for data collection and visualization. In this tutorial, we will learn how to create a channel and upload data to it using an ESP32."
  },
  {
    "objectID": "tutorials/cloud-connectivity.html#creating-a-thingspeak-channel",
    "href": "tutorials/cloud-connectivity.html#creating-a-thingspeak-channel",
    "title": "14  Cloud connectivity",
    "section": "14.2 Creating a ThingSpeak Channel",
    "text": "14.2 Creating a ThingSpeak Channel\n\nSign in or create an account on the ThingSpeak website.\nClick on “Channels” and then click “New Channel”.\nFill in the required fields, such as the name and description of the channel, as well as the fields for the data you want to collect. You can have up to 8 fields in a channel.\nClick “Save Channel”.\nOnce you have created your channel, you will be taken to the Channel page.\nOn this page, you will see your Channel ID listed under the channel name.\nTo get your Write API Key, click on the “API Keys” tab at the top of the screen.\nUnder the “Write API Key” section, you will see your unique Write API Key.\n\nMake sure to keep your Write API Key private as it is used to allow your device to upload data to your ThingSpeak channel."
  },
  {
    "objectID": "tutorials/cloud-connectivity.html#uploading-data-to-thingspeak-with-esp32",
    "href": "tutorials/cloud-connectivity.html#uploading-data-to-thingspeak-with-esp32",
    "title": "14  Cloud connectivity",
    "section": "14.3 Uploading Data to ThingSpeak with ESP32",
    "text": "14.3 Uploading Data to ThingSpeak with ESP32\nThis code is an example of how to send data from an ESP32 microcontroller to the ThingSpeak platform using WiFi. The ESP32 reads sensor data (in this example, arbitrary values are set as fields) and sends them to the ThingSpeak server periodically. The code includes the necessary network credentials and ThingSpeak channel and API key information. The code is well-commented to explain what each part of the program does.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n#include &lt;WiFi.h&gt;\n\n// Include the ThingSpeak library\n#include \"ThingSpeak.h\"\n\n// Set the ThingSpeak channel and API key information\nunsigned long myChannelNumber = 1689148;\nconst char* myWriteAPIKey = \"A58V29JE8UIGWI16\";\n\n// Set the WiFi network credentials\nconst char* ssid = \"HUJI-guest\"; // your wifi SSID name\nconst char* password = \"\"; // wifi password\n\n// Set the ThingSpeak server address\nconst char* server = \"api.thingspeak.com\";\n\n// Create a WiFiClient object to connect to the WiFi network\nWiFiClient client;\n\n// Set the time to wait between uploading data to ThingSpeak (in milliseconds)\nint wait_between_uploads = 10000; // 10 seconds\n\nvoid setup() {\n  // Start the serial communication at 112500 baud\n  Serial.begin(112500);\n\n  // Disconnect any previous WiFi connection\n  WiFi.disconnect();\n  delay(10);\n\n  // Connect to the WiFi network\n  WiFi.begin(ssid, password);\n  Serial.print(\"Connecting to \");\n  Serial.println(ssid);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"ESP32 connected to WiFi: \");\n  Serial.println(ssid);\n  Serial.println();\n\n  // Initialize the ThingSpeak library with the WiFi client\n  ThingSpeak.begin(client);\n}\n\nvoid loop() {\n  // Set the values to be sent to ThingSpeak\n  ThingSpeak.setField(1, 11);\n  ThingSpeak.setField(2, 22);\n  ThingSpeak.setField(3, 33);\n  ThingSpeak.setField(4, 44);\n\n  // Send the data to ThingSpeak\n  ThingSpeak.writeFields(myChannelNumber, myWriteAPIKey);\n\n  // Print a message to the serial monitor indicating that the data has been uploaded\n  Serial.println(\"Uploaded to ThingSpeak server.\");\n\n  // Disconnect the WiFi client\n  client.stop();\n\n  // Wait for the specified amount of time before uploading the next set of data\n  // thingspeak needs minimum 15 sec delay between updates on a free acount,\n  // a paid acount can update every 1 sec\n  Serial.println(\"Waiting to upload next reading...\");\n  Serial.println();\n  \n  delay(wait_between_uploads);\n}"
  },
  {
    "objectID": "tutorials/cloud-connectivity.html#serial-read-and-blink",
    "href": "tutorials/cloud-connectivity.html#serial-read-and-blink",
    "title": "14  Cloud connectivity",
    "section": "14.4 Serial read and blink",
    "text": "14.4 Serial read and blink\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n// Define the built-in LED pin\n#define LED_PIN LED_BUILTIN  // Most ESP32 boards use GPIO 2 for the built-in LED\n\nvoid setup() {\n  // Initialize serial communication at 115200 baud\n  Serial.begin(115200);\n  \n  // Wait for the serial monitor to connect\n  while (!Serial) {\n    ; // Wait for serial port to connect. Needed for native USB port only\n  }\n  \n  // Set the LED pin as an output\n  pinMode(LED_PIN, OUTPUT);\n  \n  // Print instructions\n  Serial.println(\"Enter the number of times you want the LED to blink:\");\n}\n\nvoid loop() {\n  // Check if data is available to read\n  if (Serial.available() &gt; 0) {\n    // Read the integer from the serial monitor\n    int blinkCount = Serial.parseInt();\n    \n    // Check if the parsed integer is greater than 0\n    if (blinkCount &gt; 0) {\n      // Print the received number\n      Serial.print(\"Blinking LED \");\n      Serial.print(blinkCount);\n      Serial.println(\" times\");\n      \n      // Blink the LED the specified number of times\n      for (int i = 0; i &lt; blinkCount; i++) {\n        digitalWrite(LED_PIN, HIGH);  // Turn on the LED\n        delay(500);                   // Wait for 500 milliseconds\n        digitalWrite(LED_PIN, LOW);   // Turn off the LED\n        delay(500);                   // Wait for 500 milliseconds\n      }\n      \n      // Print done message\n      Serial.println(\"Done blinking\");\n    }\n  }\n}"
  },
  {
    "objectID": "tutorials/cloud-connectivity.html#basic-code-for-uploading-data-to-thingspeak",
    "href": "tutorials/cloud-connectivity.html#basic-code-for-uploading-data-to-thingspeak",
    "title": "14  Cloud connectivity",
    "section": "14.5 Basic Code for Uploading Data to Thingspeak",
    "text": "14.5 Basic Code for Uploading Data to Thingspeak\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n// #include &lt;ESP8266WiFi.h&gt;\n#include &lt;WiFi.h&gt;\n\n#include \"ThingSpeak.h\"\nunsigned long myChannelNumber = write_here_the_relevant_number;\nconst char * myWriteAPIKey = \"write_here_the_correct_API_key\";\n\nconst char* ssid = \"wifi_name\"; // your wifi SSID name\nconst char* password = \"wifi_password\" ;// wifi pasword\n \nconst char* server = \"api.thingspeak.com\";\n\nWiFiClient client;\n\n\n \nvoid setup() {\n  Serial.begin(115200);\n  WiFi.disconnect();\n  delay(10);\n  WiFi.begin(ssid, password);\n\n  Serial.println();\n  Serial.println();\n  Serial.print(\"Connecting to \");\n  Serial.println(ssid);\n\n    ThingSpeak.begin(client);\n \n  WiFi.begin(ssid, password);\n  \n \n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"NodeMcu connected to wifi...\");\n  Serial.println(ssid);\n  Serial.println();\n}\n \nvoid loop() {\n\n \n  ThingSpeak.setField(1,11);\n  ThingSpeak.setField(2,22);\n  ThingSpeak.setField(3,33);\n  ThingSpeak.setField(4,44);\n  ThingSpeak.writeFields(myChannelNumber, myWriteAPIKey);\n\n  Serial.println(\"uploaded to Thingspeak server....\");\n\n  client.stop();\n \n  Serial.println(\"Waiting to upload next reading...\");\n  Serial.println();\n  // thingspeak needs minimum 15 sec delay between updates\n\n \n  \n  delay(20000);\n}"
  },
  {
    "objectID": "tutorials/cloud-connectivity.html#uploading-thermistor-data-to-thingspeak",
    "href": "tutorials/cloud-connectivity.html#uploading-thermistor-data-to-thingspeak",
    "title": "14  Cloud connectivity",
    "section": "14.6 Uploading Thermistor Data to Thingspeak",
    "text": "14.6 Uploading Thermistor Data to Thingspeak\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n#include &lt;WiFi.h&gt;\n\n// Include the ThingSpeak library\n#include \"ThingSpeak.h\"\n\n// Set the ThingSpeak channel and API key information\nunsigned long myChannelNumber = channel_number_here;\nconst char* myWriteAPIKey = \"API_key_here\";\n\n// Set the WiFi network credentials\nconst char* ssid = \"wifi_name\"; // your wifi SSID name\nconst char* password = \"wifi_password\"; // wifi password\n\n// Set the ThingSpeak server address\nconst char* server = \"api.thingspeak.com\";\n\n// Create a WiFiClient object to connect to the WiFi network\nWiFiClient client;\n\n// Set the time to wait between uploading data to ThingSpeak (in milliseconds)\nint wait_between_uploads = 10000; // 10 seconds\n\n// Thermistor setup------------------------------------------------------------------\nconst int analog_pin = A4; // Pin into which we connect the input voltage\nint val ;  // variable to store the value read\nfloat v2; // variable to store the voltage of v2\nint r1 = 10000; // R1 value (in the voltage divider)\nfloat v1 = 3.3; // V1 value\nint b_val = 4150; // B value of the resistor (from the data sheet)\nfloat r2; // variable to store the resistance of r2 (thermistor resistance)\nfloat t; // variable to store the temperature\nint adc_steps = 4095; // the number of increments our ADC has (ESP32 = 12bit)\nfloat r_25 = 10000; // the thermistor resistance at 25C (from the data sheet)\n\n// function to convert resistance to temperature according to the b value\n// equation in this link:\n// https://www.thinksrs.com/downloads/programs/therm%20calc/ntccalibrator/ntccalculator.html\nfloat resistance_to_temperature(int b, float r, float r_25) {\n  return b/(log(r/r_25)+(b/298.15))-273.15;\n}\n\n\nvoid setup() {\n  // Start the serial communication at 112500 baud\n  Serial.begin(112500);\n\n  // Disconnect any previous WiFi connection\n  WiFi.disconnect();\n  delay(10);\n\n  // Connect to the WiFi network\n  WiFi.begin(ssid, password);\n  Serial.print(\"Connecting to \");\n  Serial.println(ssid);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"ESP32 connected to WiFi: \");\n  Serial.println(ssid);\n  Serial.println();\n\n  // Initialize the ThingSpeak library with the WiFi client\n  ThingSpeak.begin(client);\n}\n\nvoid loop() {\n\n  val = analogRead(analog_pin);  // read the input pin (reading v2)\n  v2 = (v1/adc_steps)*val;  // convert to voltage of v2 according to ADC\n  r2 = (v2*r1)/(v1-v2);\n  t = resistance_to_temperature(b_val, r2, r_25);\n  Serial.print(\"Temperature: \");\n  Serial.print(t);          // print temperature\n  Serial.println(\" C\");\n\n  // Set the values to be sent to ThingSpeak\n  ThingSpeak.setField(1, t);\n\n  // Send the data to ThingSpeak\n  ThingSpeak.writeFields(myChannelNumber, myWriteAPIKey);\n\n  // Print a message to the serial monitor indicating that the data has been uploaded\n  Serial.println(\"Uploaded to ThingSpeak server.\");\n\n  // Disconnect the WiFi client\n  client.stop();\n\n  // Wait for the specified amount of time before uploading the next set of data\n  // thingspeak needs minimum 15 sec delay between updates on a free acount,\n  // a paid acount can update every 1 sec\n  Serial.println(\"Waiting to upload next reading...\");\n  Serial.println();\n  \n  delay(wait_between_uploads);\n}"
  },
  {
    "objectID": "tutorials/merging.html#code-1",
    "href": "tutorials/merging.html#code-1",
    "title": "15  Code Merging",
    "section": "15.1 Code 1",
    "text": "15.1 Code 1\n#include &lt;Random.h&gt;\n\nRandom random;\n\nvoid setup() {\n  pinMode(2, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(2, HIGH);\n  delay(random.nextInt(500));\n  digitalWrite(2, LOW);\n  delay(random.nextInt(500));\n}"
  },
  {
    "objectID": "tutorials/merging.html#code-2",
    "href": "tutorials/merging.html#code-2",
    "title": "15  Code Merging",
    "section": "15.2 Code 2",
    "text": "15.2 Code 2\n#include &lt;Random.h&gt;\n\nRandom random;\n\nvoid setup() {\n  pinMode(3, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(3, HIGH);\n  delay(random.nextInt(1000));\n  digitalWrite(3, LOW);\n  delay(random.nextInt(1000));\n}"
  },
  {
    "objectID": "tutorials/merging.html#merged-code",
    "href": "tutorials/merging.html#merged-code",
    "title": "15  Code Merging",
    "section": "15.3 Merged Code",
    "text": "15.3 Merged Code\n#include &lt;Random.h&gt;\n\nint led1 = 2;\nint led2 = 3;\nRandom random;\n\nvoid setup() {\n  pinMode(led1, OUTPUT);\n  pinMode(led2, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(led1, HIGH);\n  delay(random.nextInt(500));\n  digitalWrite(led1, LOW);\n  delay(random.nextInt(500));\n  \n  digitalWrite(led2, HIGH);\n  delay(random.nextInt(1000));\n  digitalWrite(led2, LOW);\n  delay(random.nextInt(1000));\n}\nIn this example, we start by merging the code from both sketches into a single sketch. We declare the Random library and a new variable random of type Random outside of the void functions to ensure that it’s available to all functions within the sketch.\nWe also declare two new variables led1 and led2 to store the pin numbers of the two LEDs. The setup() function is modified to set both LED pins as outputs. The loop() function is modified to use the digitalWrite() and delay() functions to blink each LED in turn with a random delay time.\nOnce you have created the merged code, you can upload it to your Arduino board and test it out. This process can become more complicated as the codes you are merging become more complex, but the basic principles remain the same: identify conflicting libraries, update pin assignments and variables, merge the setup() and loop() functions, and test and debug thoroughly."
  },
  {
    "objectID": "tutorials/RGB.html",
    "href": "tutorials/RGB.html",
    "title": "16  RGB LED",
    "section": "",
    "text": "The ESP32 board we are using has an built in RGB LED on pin D8. The following code is an example of how to use it. Please note that it requires the installation of the \"Freenove_WS2812_Lib_for_ESP32.h\" library. It can be found in the Arduino IDE library manager or downloaded from the github repository. If you are not sure how to install a library follow our guide.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n// Include the library for controlling WS2812 LEDs using ESP32\n// https://github.com/Freenove/Freenove_WS2812_Lib_for_ESP32\n#include \"Freenove_WS2812_Lib_for_ESP32.h\" \n\n// Define the number of LEDs and the pin they are connected to\n#define LEDS_COUNT 1\n#define LEDS_PIN D8\n#define CHANNEL 0\n\n// Create an instance of the WS2812 LED strip with the specified number of LEDs, pin number, and color type\nFreenove_ESP32_WS2812 strip = Freenove_ESP32_WS2812(LEDS_COUNT, LEDS_PIN, CHANNEL, TYPE_GRB);\n\n// Define an array of colors to cycle through\n// u8 = unsigned 8-bit integer (a byte), capable of holding numbers from 0 t0 255\n//                  R    G    B\nu8 m_color[][3] = {{255, 0,   0  },        // red\n                   {0,   255, 0  },        // green\n                   {0,   0,   255},        // blue\n                   {255, 255, 255},        // white\n                   {255, 255, 0  },        // yellow\n                   {255, 0  , 255},        // magenta\n                   {0,   255, 255},        // cyan\n                   {0,   0,   0}           // black\n                  };\n// number of colors = total bytes in m_color divided by bytes in m_color[0\nint N_colors = sizeof(m_color) / sizeof(m_color[0]);\n// Setup function - runs once when the microcontroller starts up\nvoid setup() {\n  // Initialize the LED strip\n  strip.begin();\n  // Set the brightness of the LEDs to 50%\n  strip.setBrightness(50);\n}\n\n// Loop function - runs repeatedly while the microcontroller is powered on\nvoid loop() {\n  // 1.\n  // Cycle through the array of colors defined before\n  for (int j = 0; j &lt; N_colors; j++) {\n    // Set LED to the current color and display the result\n    for (int i = 0; i &lt; LEDS_COUNT; i++) {\n      strip.setLedColorData(i, m_color[j][0],\n                               m_color[j][1],\n                               m_color[j][2]\n                           );\n      strip.show();\n      delay(500); // milliseconds\n    }\n  }\n  delay(1000);  // milliseconds\n  // 2.\n  // Cycle through a range of colors using the Wheel function\n  for (int j = 0; j &lt; 255; j++) {\n    strip.setLedColorData(0, strip.Wheel(j));\n    strip.show();\n    delay(10);\n  }\n  // 3.\n  // make LED black and wait 1 second before starting all over\n  for (int j = 0; j &lt; 255; j++) {\n    strip.setLedColorData(0, 0, 0, 0);\n    strip.show();\n  }\n  delay(1000);  // milliseconds\n}"
  },
  {
    "objectID": "tutorials/relay.html#toggle-switch",
    "href": "tutorials/relay.html#toggle-switch",
    "title": "17  Switches, Relays, Transistors",
    "section": "17.1 Toggle Switch",
    "text": "17.1 Toggle Switch\nNo code is needed here, we use the ESP32 just as a power source.\n\n\nsee diagram\n\n\n\n\n\nsee wiring scheme"
  },
  {
    "objectID": "tutorials/relay.html#relay",
    "href": "tutorials/relay.html#relay",
    "title": "17  Switches, Relays, Transistors",
    "section": "17.2 Relay",
    "text": "17.2 Relay\n\nA relay is an electromagnetic switch that opens and closes circuits electromechanically or electronically. A relatively small electric current that can turn on or off a much larger electric current operates a relay.\nThe right side in the image above has a set of four pins and a set of three pins. The top set consists of:\n\nVCC should be connected to the ESP32 VCC (5 volts)\nGND connects to the ESP32 GND.\nIN1 and IN2 are input pins, used to control the bottom and top relays, respectively, and should be connected to a GPIO pin in the ESP32.\n\nThe terminals on the left are connected to the load, the equipment that consumes power. The signal you send to the IN pins determines whether the relay is active or not. The relay is triggered when the input goes below about 2V. This means that you’ll have the following scenarios:\n\nNormally Closed (NC) configuration:\n\nHIGH signal – current is flowing\nLOW signal – current is not flowing\n\nNormally Open (NO) configuration:\n\nHIGH signal – current is not flowing\nLOW signal – current is flowing\n\n\nWhether you use the NC or NO configuration, you should always connect one of them to the COM (common) terminal.\nYou should use a normally closed configuration when the current should be flowing most of the time, and you only want to stop it occasionally.\nUse a normally open configuration when you want the current to flow occasionally (for example, to turn on a lamp occasionally).\n\nThe other set of three pins (on the left in the figure above) are GND, VCC, and JD-VCC. The JD-VCC pin powers the electromagnet of the relay. Notice that the module has a jumper cap connecting the VCC and JD-VCC pins; the one shown here is yellow, but yours may be a different color.\nWith the jumper cap on, the VCC and JD-VCC pins are connected. That means the relay electromagnet is directly powered from the ESP32 power pin, so the relay module and the ESP32 circuits are not physically isolated from each other.\nWithout the jumper cap, you need to provide an independent power source to power up the relay’s electromagnet through the JD-VCC pin. That configuration physically isolates the relays from the ESP32 with the module’s built-in optocoupler, which prevents damage to the ESP32 in case of electrical spikes.\nLet’s make an LED blink, but now using a relay. The code below is the same you used to make the LED blink, when it got its energy from pin A4. This time, we will use A4 to signal the relay to open or close the circuit.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nint LED_pin = A4;\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n  // initialize digital pin LED_pin as an output.\n  pinMode(LED_pin, OUTPUT);\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n  digitalWrite(LED_pin, HIGH);   // turn the LED on (HIGH is the voltage level)\n  delay(3000);                       // wait for a second\n  digitalWrite(LED_pin, LOW);    // turn the LED off by making the voltage LOW\n  delay(1000);                       // wait for a second\n}\n\n            \n            \n            \n\n\nsee diagram\n\n\n\n\n\nsee wiring scheme"
  },
  {
    "objectID": "tutorials/relay.html#transistor-n-channel-mosfet",
    "href": "tutorials/relay.html#transistor-n-channel-mosfet",
    "title": "17  Switches, Relays, Transistors",
    "section": "17.3 Transistor, N-channel MOSFET",
    "text": "17.3 Transistor, N-channel MOSFET"
  },
  {
    "objectID": "tutorials/soldering-and-wires.html",
    "href": "tutorials/soldering-and-wires.html",
    "title": "18  Soldering and Wires",
    "section": "",
    "text": "soldering\n\n\nBreadbord is fun and easy but sooner or later everyone working with Arduino will need to know how to solder and work with wires. There are amazing tutorials that allready exist. Even though we will learn many of the topics in class, we strongly recomend to take a look at these tutorials.\n\nSoldering - by Sparkfun\nSoldering - by Adafruit (note that this is a multi page guide)\nWorking with wire - by Sparkfun"
  },
  {
    "objectID": "tutorials/electronics-class-old.html#presentation",
    "href": "tutorials/electronics-class-old.html#presentation",
    "title": "19  Electronics Class Old",
    "section": "19.1 Presentation",
    "text": "19.1 Presentation\nDownload presentation pdf"
  },
  {
    "objectID": "tutorials/electronics-class-old.html#circuit-diagrams",
    "href": "tutorials/electronics-class-old.html#circuit-diagrams",
    "title": "19  Electronics Class Old",
    "section": "19.2 Circuit diagrams",
    "text": "19.2 Circuit diagrams\nMake your own circuit diagrams here: https://www.circuit-diagram.org/editor/"
  },
  {
    "objectID": "tutorials/electronics-class-old.html#digital-write",
    "href": "tutorials/electronics-class-old.html#digital-write",
    "title": "19  Electronics Class Old",
    "section": "19.3 Digital Write",
    "text": "19.3 Digital Write\nUse the following code to activate LED pin.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nint LED_pin = A4;\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n  // initialize digital pin LED_pin as an output.\n  pinMode(LED_pin, OUTPUT);\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n  digitalWrite(LED_pin, HIGH);   // turn the LED on (HIGH is the voltage level)\n  delay(1000);                       // wait for a second\n  digitalWrite(LED_pin, LOW);    // turn the LED off by making the voltage LOW\n  delay(1000);                       // wait for a second\n}"
  },
  {
    "objectID": "tutorials/electronics-class-old.html#pwm-with-esp32",
    "href": "tutorials/electronics-class-old.html#pwm-with-esp32",
    "title": "19  Electronics Class Old",
    "section": "19.4 PWM with ESP32",
    "text": "19.4 PWM with ESP32\nPulse-width modulation (PWM) is a method of controlling the average power delivered by an electrical signal. The average value of voltage (and current) fed to the load is controlled by switching the supply between 0 and 100% at a rate faster than it takes the load to change significantly. PWM is a technique for getting analog results with digital means. Digital control is used to create a square wave, a signal switched between on and off. This on-off pattern can simulate voltages in between the full Vcc of the board and off by changing the portion of time the signal spends on versus the time that the signal spends off. PWM is used in many applications such as controlling motor speed, heat output of heaters and variable speed fan controllers.\n\nUse the following code to activate LED pin with PWM.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n// the number of the LED pin\nconst int ledPin = D9;\n\n// setting PWM properties\nconst int freq = 5000;\nconst int ledChannel = 0;\nconst int resolution = 8;\n \nvoid setup(){\n  // configure LED PWM functionalitites\n  ledcSetup(ledChannel, freq, resolution);\n  \n  // attach the channel to the GPIO to be controlled\n  ledcAttachPin(ledPin, ledChannel);\n}\n \nvoid loop(){\n  // increase the LED brightness\n  for(int dutyCycle = 0; dutyCycle &lt;= 255; dutyCycle++){   \n    // changing the LED brightness with PWM\n    ledcWrite(ledChannel, dutyCycle);\n    delay(15);\n  }\n\n  // decrease the LED brightness\n  for(int dutyCycle = 255; dutyCycle &gt;= 0; dutyCycle--){\n    // changing the LED brightness with PWM\n    ledcWrite(ledChannel, dutyCycle);   \n    delay(15);\n  }\n}"
  },
  {
    "objectID": "tutorials/electronics-class-old.html#reading-an-analog-pin",
    "href": "tutorials/electronics-class-old.html#reading-an-analog-pin",
    "title": "19  Electronics Class Old",
    "section": "19.5 Reading an Analog Pin",
    "text": "19.5 Reading an Analog Pin\nUse the following code to read an analog pin.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nconst int analog_pin = A4; // Pin into which we connect the input voltage\nint val ;  // variable to store the value read\n\n\nvoid setup() {\n  Serial.begin(115200); //\n}\n\nvoid loop() {\n  val = analogRead(analog_pin);  // read the input pin\n  Serial.println(val);          // print value\n  delay(100);\n}"
  },
  {
    "objectID": "tutorials/electronics-class-old.html#adc-to-voltage",
    "href": "tutorials/electronics-class-old.html#adc-to-voltage",
    "title": "19  Electronics Class Old",
    "section": "19.6 ADC to voltage",
    "text": "19.6 ADC to voltage\nUse the following code to convert ADC reading to voltage.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nconst int analog_pin = A4; // Pin into which we connect the input voltage\nint val ;  // variable to store the value read\nfloat voltage;\n\nvoid setup() {\n  Serial.begin(115200); //\n}\n\nvoid loop() {\n  val = analogRead(analog_pin);  // read the input pin\n  voltage = (3.3/4095)*val;  // convert to voltage according to ADC\n  Serial.print(\"Voltage: \");\n  Serial.print(voltage);          // print value\n  Serial.println(\" V\");\n  delay(100);\n}"
  },
  {
    "objectID": "tutorials/electronics-class-old.html#potentiometer-and-pwm",
    "href": "tutorials/electronics-class-old.html#potentiometer-and-pwm",
    "title": "19  Electronics Class Old",
    "section": "19.7 Potentiometer and PWM",
    "text": "19.7 Potentiometer and PWM\nUse the following code to control PWM with potentiometer and dim the LED.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nconst int ledPin = D9; // the number of the LED pin\nint analog_pin = A4; // Pin into which we connect the middle leg of the potentiometer\nint val ;  // variable to store the value read\n\n// setting PWM properties\nconst int freq = 5000;        // 5000 Hz\nconst int ledChannel = 0;\nconst int resolution = 12;    // 12-bit resolution = between 0 and 4095\n \nvoid setup(){\n  Serial.begin(115200);\n    \n  // configure LED PWM functionalitites\n  ledcSetup(ledChannel, freq, resolution);\n  \n  // attach the channel to the GPIO to be controlled\n  ledcAttachPin(ledPin, ledChannel);\n}\n \nvoid loop(){\n    val = analogRead(analog_pin);  // read the input pin\n    Serial.println(val);          // print value\n    ledcWrite(ledChannel, val);\n    delay(15);  // update duty cycle parameters every 15 ms\n  }"
  },
  {
    "objectID": "tutorials/electronics-class-old.html#thermistor",
    "href": "tutorials/electronics-class-old.html#thermistor",
    "title": "19  Electronics Class Old",
    "section": "19.8 Thermistor",
    "text": "19.8 Thermistor\nDownload Data Sheet\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n// Thermistor \n// reading the temperature via the ESP32's ADC\n\nconst int analog_pin = A4; // Pin into which we connect the input voltage\nint val ;  // variable to store the value read\nfloat v2; // variable to store the voltage of v2\nint r1 = 10000; // R1 value (in the voltage divider)\nfloat v1 = 3.3; // V1 value\nint b_val = 4150; // B value of the resistor (from the data sheet)\nfloat r2; // variable to store the resistance of r2 (thermistor resistance)\nfloat t; // variable to store the temperature\nint adc_steps = 4095; // the number of increments our ADC has (ESP32 = 12bit)\nfloat r_25 = 10000; // the thermistor resistance at 25C (from the data sheet)\n\n// function to convert resistance to temperature according to the b value\n// equation in this link:\n// https://www.thinksrs.com/downloads/programs/therm%20calc/ntccalibrator/ntccalculator.html\nfloat resistance_to_temperature(int b, float r, float r_25) {\n  return b/(log(r/r_25)+(b/298.15))-273.15;\n}\n\nvoid setup() {\n  Serial.begin(115200); //\n}\n\nvoid loop() {\n  val = analogRead(analog_pin);  // read the input pin (reading v2)\n  v2 = (v1/adc_steps)*val;  // convert to voltage of v2 according to ADC\n  r2 = (v2*r1)/(v1-v2);\n  t = resistance_to_temperature(b_val, r2, r_25);\n  Serial.print(\"Temperature: \");\n  Serial.print(t);          // print temperature\n  Serial.println(\" C\");\n  delay(100);\n}"
  },
  {
    "objectID": "tutorials/pulse-sensors.html#square-wave",
    "href": "tutorials/pulse-sensors.html#square-wave",
    "title": "20  Pulse sensors",
    "section": "20.1 Square wave",
    "text": "20.1 Square wave\n\n\n20.1.1 Pulse counter\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nint sensorPin = A4;\nvolatile long pulse_count;\n\nfloat volume;\n\nvoid setup() {\n  pinMode(sensorPin, INPUT);\n  Serial.begin(115200);\n  attachInterrupt(digitalPinToInterrupt(sensorPin), increase, RISING);\n}\n\nvoid loop() {\n  Serial.print(pulse_count);\n  Serial.println(\" counts\");\n  delay(50);\n}\n\nICACHE_RAM_ATTR void increase() {\n  pulse_count++;\n}\n\n            \n            \n            \n\n\n20.1.2 Calculate frequency from counts\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nint sensorPin = A4;\nvolatile long pulse_count;\nunsigned long last_print_time;\nlong total_pulse_count = 0;\nfloat volume;\n\nvoid setup() {\n  pinMode(sensorPin, INPUT);\n  Serial.begin(115200);\n  attachInterrupt(digitalPinToInterrupt(sensorPin), increase, RISING);\n  last_print_time = millis();\n}\n\nvoid loop() {\n  unsigned long current_time = millis();\n  if (current_time - last_print_time &gt;= 1000) { // print every second\n    float frequency = (float)pulse_count / ((current_time - last_print_time) / 1000.0);\n    total_pulse_count += pulse_count; // update total pulse count\n    Serial.print(total_pulse_count);\n    Serial.print(\" total counts, \");\n    Serial.print(frequency);\n    Serial.println(\" counts per second\");\n    pulse_count = 0; // reset pulse count\n    last_print_time = current_time;\n  }\n}\n\nICACHE_RAM_ATTR void increase() {\n  pulse_count++;\n}"
  },
  {
    "objectID": "tutorials/MQTT.html#intro",
    "href": "tutorials/MQTT.html#intro",
    "title": "21  MQTT",
    "section": "21.1 Intro",
    "text": "21.1 Intro\nIn today’s session, we will be diving into the fascinating world of MQTT and its relevance in the field of agriculture. MQTT, which stands for Message Queuing Telemetry Transport, is a lightweight and efficient messaging protocol designed for constrained devices and low-bandwidth networks.\nIn the realm of AgroTech, where the Internet of Things (IoT) plays a crucial role, MQTT offers a powerful solution for connecting sensors, actuators, and other devices in agricultural systems. It provides a reliable and scalable means of communication, enabling seamless data exchange between devices, networks, and applications.\nOne of the primary advantages of MQTT is its lightweight nature, making it ideal for resource-constrained devices such as the ESP32 microcontroller. With its small code footprint and minimal network overhead, MQTT facilitates efficient data transmission even in remote or challenging agricultural environments.\nThrough the use of MQTT, farmers and agriculturalists can gather real-time information about various aspects of their operations, including temperature, humidity, soil moisture, and crop health. This data can then be transmitted to centralized servers or cloud platforms, allowing for intelligent analysis, decision-making, and automation in the agricultural domain.\nFurthermore, MQTT follows a publish-subscribe messaging pattern, enabling a scalable and flexible communication model. Devices can publish data to specific topics, and other devices or applications can subscribe to these topics to receive relevant information. This decoupled architecture ensures that data is delivered only to those who need it, minimizing network congestion and optimizing system performance.\nIn this AgroTech class, we will explore the implementation of MQTT on the ESP32 microcontroller, enabling you to build innovative and efficient solutions for the agricultural sector. So, let’s dive in and discover how MQTT can revolutionize the way we approach farming, enhance productivity, and contribute to sustainable agriculture practices."
  },
  {
    "objectID": "tutorials/MQTT.html#fundamental-concepts",
    "href": "tutorials/MQTT.html#fundamental-concepts",
    "title": "21  MQTT",
    "section": "21.2 Fundamental Concepts",
    "text": "21.2 Fundamental Concepts\n\nMQTT Broker:\nAt the core of MQTT is the broker, which acts as a central hub for message exchange. The broker receives messages published by clients and distributes them to the interested subscribers. It is responsible for routing messages based on topics and maintaining the overall communication flow. For our calss today we will use the Hivemq free public broker.\nMQTT Client:\nClients are devices or applications that connect to the MQTT broker. They can be sensors, actuators, microcontrollers, or any device capable of sending or receiving messages. MQTT clients can function as both publishers and subscribers, allowing them to send data and receive updates from the broker. For our class we can utilize the Hivemq online client for testing.\nTopic:\nTopics are hierarchical strings that act as labels for messages. They serve as a way to categorize and organize information. When publishing a message, clients assign it to a specific topic. Subscribers can then choose to receive messages from specific topics of interest. For example, in agriculture, topics could represent sensor data such as “temperature,” “humidity,” or “soil moisture.”\nPublish:\nPublishing refers to the action of sending a message from an MQTT client to the broker. When a client publishes a message, it specifies the topic to which the message belongs. The broker then distributes the message to all the interested subscribers that have subscribed to that particular topic.\nSubscribe:\nSubscribing allows clients to express their interest in receiving messages from specific topics. By subscribing to a topic, a client informs the broker that it wants to receive messages published to that topic. Subscriptions can be specific to a particular topic (e.g., temperature) or can use wildcard characters to subscribe to multiple topics (e.g., agriculture/+/moisture to subscribe to all moisture data in different areas of agriculture)."
  },
  {
    "objectID": "tutorials/MQTT.html#a-bit-more-about-topics",
    "href": "tutorials/MQTT.html#a-bit-more-about-topics",
    "title": "21  MQTT",
    "section": "21.3 A bit more about topics",
    "text": "21.3 A bit more about topics\nTopics in MQTT are written as hierarchical strings, consisting of one or more levels separated by forward slashes (/). Each level within a topic provides a level of categorization and organization for the messages.\nFor example, consider the topic structure in agriculture:\n\nagriculture/temperature: This topic represents the temperature data in the agricultural context. It consists of a single level, agriculture followed by another level, temperature.\nagriculture/field1/humidity: This topic represents the humidity data in a specific field. It consists of three levels: agriculture, field1, and humidity.\nagriculture/+/soil moisture: This topic uses a wildcard character, +, which can match exactly one topic level. Subscribing to this topic would allow receiving messages related to soil moisture from various areas within agriculture.\nagriculture/#: This topic uses the wildcard character #, which can match multiple levels or no level at all. Subscribing to this topic would enable receiving messages from any sub-topic under agriculture.\n\nThe use of forward slashes and levels in topic design allows for a structured approach to organizing data in MQTT. It enables subscribers to select specific levels or use wildcard characters to filter and receive messages of interest.\nWhen publishing a message, the client specifies the topic to which the message belongs, ensuring that it is appropriately categorized and can be received by subscribers who are interested in that specific topic.\nUnderstanding how topics are written and structured is crucial for effective message routing and data organization within MQTT-based AgroTech applications."
  },
  {
    "objectID": "tutorials/MQTT.html#led-subscribe",
    "href": "tutorials/MQTT.html#led-subscribe",
    "title": "21  MQTT",
    "section": "21.4 LED subscribe",
    "text": "21.4 LED subscribe\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n//addapted from:\n//https://microcontrollerslab.com/esp32-mqtt-client-publish-subscribe-bme280-readings-hivemq/\n\n#include &lt;Arduino.h&gt;\n#include &lt;WiFi.h&gt;\n#include &lt;PubSubClient.h&gt;\n\nWiFiClient wifiClient;\nPubSubClient mqttClient(wifiClient); \n\nconst char* ssid = \"wifi_name\";\nconst char* password = \"wifi_password\";\n\nchar *mqttServer = \"broker.hivemq.com\";\nint mqttPort = 1883;\n\nint LED_pin = A4;\nString msgString; // Declare msgString variable in the global scope\n\nvoid setupMQTT() {\n  mqttClient.setServer(mqttServer, mqttPort);\n  mqttClient.setCallback(callback);\n}\n\nvoid reconnect() {\n  Serial.println(\"Connecting to MQTT Broker...\");\n  while (!mqttClient.connected()) {\n      Serial.println(\"Reconnecting to MQTT Broker..\");\n      String clientId = \"ESP32Client-\";\n      clientId += String(random(0xffff), HEX);\n      \n      if (mqttClient.connect(clientId.c_str())) {\n        Serial.println(\"Connected.\");\n        // subscribe to topic\n        mqttClient.subscribe(\"agrotech/mqtt_tutorial/LED\");\n      }      \n  }\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  WiFi.begin(ssid, password);\n    while (WiFi.status() != WL_CONNECTED) {\n      delay(500);\n      Serial.print(\".\");\n    } \n    Serial.println(\"\");\n     Serial.println(\"Connected to Wi-Fi\");\n\n  setupMQTT();\n\n  pinMode(LED_pin, OUTPUT);\n  digitalWrite(LED_pin, LOW); \n  \n}\n\n\nvoid loop() {\n  if (!mqttClient.connected()) {\n      reconnect();\n  }\n    \n  mqttClient.loop();\n  long now = millis();\n}\n\n\n\nvoid callback(char* topic, byte* message, unsigned int length) {\n  // Convert byte array to string\n  msgString = String((char*)message, length);\n\n  // Convert string to integer\n  int ledState = msgString.toInt();\n\n  Serial.print(\"Message: \");\n  Serial.println(msgString);\n  Serial.print(\"LED State: \");\n  Serial.println(ledState);\n\n  if (ledState == 1) {\n    digitalWrite(LED_pin, HIGH);  // Set pin A4 high\n  } else if (ledState == 0) {\n    digitalWrite(LED_pin, LOW);   // Set pin A4 low\n  }\n}"
  },
  {
    "objectID": "tutorials/MQTT.html#publish-text",
    "href": "tutorials/MQTT.html#publish-text",
    "title": "21  MQTT",
    "section": "21.5 Publish text",
    "text": "21.5 Publish text\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n#include &lt;Arduino.h&gt;\n#include &lt;WiFi.h&gt;\n#include &lt;PubSubClient.h&gt;\n\nWiFiClient wifiClient;\nPubSubClient mqttClient(wifiClient); \n\nconst char* ssid = \"wifi_name\";\nconst char* password = \"wifi_password\";\n\nconst char* mqttServer = \"broker.hivemq.com\";\nint mqttPort = 1883;\n\nlong previous_time = 0;\nconst char* messageToSend = \"This is my fuuny message\"; // Message as a variable\n\nvoid setupMQTT() {\n  mqttClient.setServer(mqttServer, mqttPort);\n}\n\nvoid reconnect() {\n  Serial.println(\"Connecting to MQTT Broker...\");\n  while (!mqttClient.connected()) {\n    Serial.println(\"Reconnecting to MQTT Broker..\");\n    String clientId = \"ESP32Client-\";\n    clientId += String(random(0xffff), HEX);\n    \n    if (mqttClient.connect(clientId.c_str())) {\n      Serial.println(\"Connected.\");\n    }      \n  }\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  } \n  Serial.println(\"\");\n  Serial.println(\"Connected to Wi-Fi\");\n\n  setupMQTT();\n}\n\nvoid loop() {\n  if (!mqttClient.connected())\n    reconnect();\n  mqttClient.loop();\n  long now = millis();\n\n  if (now - previous_time &gt; 5000) {\n    previous_time = now;\n    mqttClient.publish(\"agrotech/mqtt_tutorial/message\", messageToSend);\n  }\n}"
  },
  {
    "objectID": "tutorials/MQTT.html#sensor-subscribe",
    "href": "tutorials/MQTT.html#sensor-subscribe",
    "title": "21  MQTT",
    "section": "21.6 Sensor subscribe",
    "text": "21.6 Sensor subscribe\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n//addapted from:\n//https://microcontrollerslab.com/esp32-mqtt-client-publish-subscribe-bme280-readings-hivemq/\n\n#include &lt;Arduino.h&gt;\n#include &lt;WiFi.h&gt;\n#include &lt;PubSubClient.h&gt;\n\nWiFiClient wifiClient;\nPubSubClient mqttClient(wifiClient); \n\nconst char* ssid = \"wifi_name\";\nconst char* password = \"wifi_password\";\n\nchar *mqttServer = \"broker.hivemq.com\";\nint mqttPort = 1883;\n\nfloat value = 0;\nString msgString; // Declare msgString variable in the global scope\n\nvoid setupMQTT() {\n  mqttClient.setServer(mqttServer, mqttPort);\n  mqttClient.setCallback(callback);\n}\n\nvoid reconnect() {\n  Serial.println(\"Connecting to MQTT Broker...\");\n  while (!mqttClient.connected()) {\n      Serial.println(\"Reconnecting to MQTT Broker..\");\n      String clientId = \"ESP32Client-\";\n      clientId += String(random(0xffff), HEX);\n      \n      if (mqttClient.connect(clientId.c_str())) {\n        Serial.println(\"Connected.\");\n        // subscribe to topic\n        mqttClient.subscribe(\"agrotech/mqtt_tutorial/temperature\");\n      }      \n  }\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  WiFi.begin(ssid, password);\n    while (WiFi.status() != WL_CONNECTED) {\n      delay(500);\n      Serial.print(\".\");\n    } \n    Serial.println(\"\");\n     Serial.println(\"Connected to Wi-Fi\");\n\n  setupMQTT();\n\n}\n\n\nvoid loop() {\n  if (!mqttClient.connected()) {\n      reconnect();\n  }\n    \n  mqttClient.loop();\n  long now = millis();\n}\n\n\n\nvoid callback(char* topic, byte* message, unsigned int length) {\n  // Convert byte array to string\n  msgString = String((char*)message, length);\n\n  // Convert string to float\n  value = msgString.toFloat();\n\n  Serial.println(value);\n\n}"
  },
  {
    "objectID": "tutorials/MQTT.html#publish-and-subscribe",
    "href": "tutorials/MQTT.html#publish-and-subscribe",
    "title": "21  MQTT",
    "section": "21.7 Publish and subscribe",
    "text": "21.7 Publish and subscribe\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n//addapted from:\n//https://microcontrollerslab.com/esp32-mqtt-client-publish-subscribe-bme280-readings-hivemq/\n\n#include &lt;Arduino.h&gt;\n#include &lt;WiFi.h&gt;\n#include &lt;PubSubClient.h&gt;\n\nWiFiClient wifiClient;\nPubSubClient mqttClient(wifiClient); \n\nconst char* ssid = \"TP-Link_905D\";\nconst char* password = \"33072036\";\n\nchar *mqttServer = \"broker.hivemq.com\";\nint mqttPort = 1883;\n\nlong previous_time = 0;\nString msgString; // Declare msgString variable in the global scope\n\nvoid setupMQTT() {\n  mqttClient.setServer(mqttServer, mqttPort);\n  mqttClient.setCallback(callback);\n}\n\nvoid reconnect() {\n  Serial.println(\"Connecting to MQTT Broker...\");\n  while (!mqttClient.connected()) {\n      Serial.println(\"Reconnecting to MQTT Broker..\");\n      String clientId = \"ESP32Client-\";\n      clientId += String(random(0xffff), HEX);\n      \n      if (mqttClient.connect(clientId.c_str())) {\n        Serial.println(\"Connected.\");\n        // subscribe to topic\n        mqttClient.subscribe(\"agrotech/2023/message\");\n      }      \n  }\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  WiFi.begin(ssid, password);\n    while (WiFi.status() != WL_CONNECTED) {\n      delay(500);\n      Serial.print(\".\");\n    } \n    Serial.println(\"\");\n     Serial.println(\"Connected to Wi-Fi\");\n\n  setupMQTT();\n}\n\n\nvoid loop() {\n  if (!mqttClient.connected())\n    reconnect();\n  mqttClient.loop();\n  long now = millis();\n\n  if (now - previous_time &gt; 1000) {\n    previous_time = now;\n\n    float temperature = random(1, 101);\n    char tempString[8];\n    dtostrf(temperature, 1, 2, tempString);\n    Serial.print(\"Temperature: \");\n    Serial.println(tempString);\n    mqttClient.publish(\"agrotech/2023/temperature\", tempString);\n\n    mqttClient.publish(\"agrotech/2023/string\", \"Hi :)\");\n\n//    Serial.print(\"Subscribed Message: \");\n//    Serial.println(msgString);\n  }\n}\n\n\nvoid callback(char* topic, byte* message, unsigned int length) {\n  // Convert byte array to string\n //  String msgString((char*)message, length);\n\n  msgString = String((char*)message, length);\n  \n  // Convert string to float\n  float msgFloat = msgString.toFloat();\n\n  // Convert string to integer\n  int msgInt = msgString.toInt();\n  \n  Serial.print(\"Message: \");\n  Serial.println(msgString);\n  Serial.print(\"Float: \");\n  Serial.println(msgFloat);\n  Serial.print(\"Integer: \");\n  Serial.println(msgInt);\n}"
  },
  {
    "objectID": "tutorials/MQTT.html#mqtt-python",
    "href": "tutorials/MQTT.html#mqtt-python",
    "title": "21  MQTT",
    "section": "21.8 MQTT + Python",
    "text": "21.8 MQTT + Python"
  },
  {
    "objectID": "tutorials/MQTT.html#subscribe",
    "href": "tutorials/MQTT.html#subscribe",
    "title": "21  MQTT",
    "section": "21.9 Subscribe",
    "text": "21.9 Subscribe\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nimport paho.mqtt.client as mqtt\n\n# MQTT broker details\nbroker_address = \"broker.hivemq.com\"\nbroker_port = 1883\n\n# Callback function when a connection is established with the MQTT broker\ndef on_connect(client, userdata, flags, rc):\n    print(\"Connected to MQTT broker with result code: \" + str(rc))\n    # Subscribe to the topic upon successful connection\n    client.subscribe(\"agrotech/mqtt_tutorial/#\")\n\n# Callback function when a message is received\ndef on_message(client, userdata, msg):\n    print(\"Received message: \" + str(msg.payload.decode()))\n\n# Create a MQTT client instance\nclient = mqtt.Client()\n\n# Assign callback functions\nclient.on_connect = on_connect\nclient.on_message = on_message\n\n# Connect to the MQTT broker\nclient.connect(broker_address, broker_port, 60)\n\n# Loop to maintain the connection and process network traffic\nclient.loop_forever()"
  },
  {
    "objectID": "tutorials/MQTT.html#publish",
    "href": "tutorials/MQTT.html#publish",
    "title": "21  MQTT",
    "section": "21.10 Publish",
    "text": "21.10 Publish\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nimport paho.mqtt.client as mqtt\nimport random\nimport time\n\n# MQTT broker details\nbroker_address = \"broker.hivemq.com\"\nbroker_port = 1883\n\n# Create a MQTT client instance\nclient = mqtt.Client()\n\n# Connect to the MQTT broker\nclient.connect(broker_address, broker_port, 60)\n\ntemperature = 20.0\n# Loop to publish random temperature readings\nwhile True:\n    temperature = temperature + random.uniform(-1, 1)  # Generate a random temperature value between 20.0 and 30.0\n    client.publish(\"agrotech/mqtt_tutorial/temperature\", str(temperature))  # Publish the temperature value to the topic\n    print(\"Published temperature: \" + str(temperature))\n    time.sleep(1)  # Wait for 5 seconds before publishing the next temperature reading\n\n# Disconnect from the MQTT broker (not reached in this example)\nclient.disconnect()"
  },
  {
    "objectID": "tutorials/MQTT.html#subscribe-to-csv",
    "href": "tutorials/MQTT.html#subscribe-to-csv",
    "title": "21  MQTT",
    "section": "21.11 Subscribe to CSV",
    "text": "21.11 Subscribe to CSV\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \nimport paho.mqtt.client as mqtt\nimport pandas as pd\nfrom datetime import datetime\n\n# MQTT broker details\nbroker_address = \"broker.hivemq.com\"\nbroker_port = 1883\n\n# Create a DataFrame to store the messages\ndf = pd.DataFrame(columns=[\"topic\", \"value\"])\n\n# Callback function when a connection is established with the MQTT broker\ndef on_connect(client, userdata, flags, rc):\n    print(\"Connected to MQTT broker with result code: \" + str(rc))\n    # Subscribe to all subtopics within agrotech/mqtt_tutorial/\n    client.subscribe(\"agrotech/mqtt_tutorial/#\")\n\n# Callback function when a message is received\ndef on_message(client, userdata, msg):\n    global df\n    # Decode the message payload\n    value = msg.payload.decode()\n    # Extract the subtopic\n    subtopic = msg.topic.split(\"agrotech/mqtt_tutorial/\")[1]\n    # Get the current time\n    timestamp = datetime.now()\n    # Create a new DataFrame with the new message\n    new_row = pd.DataFrame({\"topic\": [subtopic], \"value\": [value]}, index=[timestamp])\n    # Append the new row to the DataFrame using concat\n    df = pd.concat([df, new_row])\n    print(f\"Received message on {msg.topic}: {value}\")\n\n# Create an MQTT client instance\nclient = mqtt.Client()\n\n# Assign callback functions\nclient.on_connect = on_connect\nclient.on_message = on_message\n\n# Connect to the MQTT broker\nclient.connect(broker_address, broker_port, 60)\n\n# Loop to maintain the connection and process network traffic\ntry:\n    client.loop_forever()\nexcept KeyboardInterrupt:\n    # Save the DataFrame to a CSV file when the script is interrupted\n    df.to_csv(\"mqtt_messages.csv\")\n    print(\"Data saved to mqtt_messages.csv\")"
  },
  {
    "objectID": "tutorials/MQTT.html#control-irrigation-solenoid-in-the-greenhouse",
    "href": "tutorials/MQTT.html#control-irrigation-solenoid-in-the-greenhouse",
    "title": "21  MQTT",
    "section": "21.12 Control irrigation solenoid in the greenhouse",
    "text": "21.12 Control irrigation solenoid in the greenhouse\nUse the code below to control the irrigation solenoid outside the greenhouse.\nCode usage: connect a jumper to A4. Whenever you touch the jumper, the solenoid will be open, otherwise it will be closed.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n#include &lt;WiFi.h&gt;\n#include &lt;PubSubClient.h&gt;\n\n// WiFi credentials\nconst char* ssid = \"agrotech\";          // Replace with your WiFi SSID\nconst char* password = \"1Afuna2gezer\";  // Replace with your WiFi Password\n\n// MQTT broker details\nconst char* mqtt_server = \"192.168.0.102\";    // IP address of Home Assistant\nconst int mqtt_port = 1883;                   // Default MQTT port\nconst char* mqtt_user = \"mqtt-user\";          // MQTT username\nconst char* mqtt_password = \"1234\";           // MQTT password\nconst char* mqtt_topic = \"/greenhouse/outside/irrigation/solenoid5\"; // MQTT topic\n\n// Touch pin configuration\n#define TOUCH_PIN A4  // Use GPIO 4 as touch pin (T0 on ESP32)\n\n// MQTT client and WiFi client\nWiFiClient espClient;\nPubSubClient client(espClient);\n\n// State variable to track touch pin state\nbool send_message = false;\n\nvoid setup_wifi() {\n  Serial.print(\"Connecting to WiFi: \");\n  Serial.println(ssid);\n  WiFi.begin(ssid, password);\n\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n\n  Serial.println(\"\\nWiFi connected\");\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid reconnect() {\n  // Attempt to reconnect to the MQTT broker\n  while (!client.connected()) {\n    Serial.print(\"Attempting MQTT connection...\");\n    if (client.connect(\"ESP32Client\", mqtt_user, mqtt_password)) {\n      Serial.println(\"connected\");\n    } else {\n      Serial.print(\"failed, rc=\");\n      Serial.print(client.state());\n      Serial.println(\" Retrying in 5 seconds...\");\n      delay(5000);\n    }\n  }\n}\n\nvoid setup() {\n  Serial.begin(115200);\n\n  // Initialize WiFi\n  setup_wifi();\n\n  // Set up MQTT\n  client.setServer(mqtt_server, mqtt_port);\n\n  // Ensure the ESP32 starts connected to the MQTT broker\n  reconnect();\n}\n\nvoid loop() {\n  if (!client.connected()) {\n    reconnect();\n  }\n  client.loop();\n\n  // Read the state of the touch pin\n  bool is_touched = touchRead(TOUCH_PIN) &lt; 40;  // If the value is less than 40, the pin is being touched\n\n  // Send \"1\" if the pin is being touched\n  if (is_touched) {\n    if (!send_message) {\n      client.publish(mqtt_topic, \"1\");\n      Serial.println(\"Sent: 1\");\n      send_message = true;  // Set flag to avoid sending multiple times while touching\n    }\n  } \n  // Send \"0\" if the pin is not being touched\n  else {\n    if (send_message) {\n      client.publish(mqtt_topic, \"0\");\n      Serial.println(\"Sent: 0\");\n      send_message = false;  // Reset the flag when pin is no longer touched\n    }\n  }\n\n  // Optional: Small delay to avoid flooding the MQTT server with messages\n  delay(100);  // Adjust the delay if necessary\n}"
  },
  {
    "objectID": "tutorials/deep_sleep.html#key-features-of-deep-sleep",
    "href": "tutorials/deep_sleep.html#key-features-of-deep-sleep",
    "title": "22  Deep Sleep",
    "section": "22.1 Key Features of Deep Sleep",
    "text": "22.1 Key Features of Deep Sleep\n\nLow Power Consumption:\nIn deep sleep mode, the ESP32 consumes only a few microamps of current, drastically reducing power usage compared to its normal operating modes.\nPreservation of Data:\nThe ESP32 can save the state of its peripherals and the values of certain variables in RTC (Real-Time Clock) memory, which is retained during deep sleep. This allows the microcontroller to resume tasks efficiently upon waking up.\nWake-Up Sources:\nThe ESP32 can be awakened from deep sleep by various events:\n\nTimer: The internal RTC can be programmed to wake the device after a specified time interval.\nExternal Pin: A change in the state of a designated GPIO pin can trigger a wake-up.\nTouch Sensor: Touch pad sensors can be used to wake up the device.\nULP Coprocessor: The Ultra-Low-Power (ULP) coprocessor can run while the main CPU is in deep sleep and trigger a wake-up event based on sensor readings or other conditions.\n\nApplication Examples:\n\nBattery-Powered Sensors: Environmental sensors that need to periodically send data can spend most of their time in deep sleep, waking up only to take measurements and transmit data.\nIoT Devices: Devices that need to conserve power, such as remote weather stations or smart home devices, can use deep sleep to extend battery life."
  },
  {
    "objectID": "tutorials/deep_sleep.html#deep-sleep-code",
    "href": "tutorials/deep_sleep.html#deep-sleep-code",
    "title": "22  Deep Sleep",
    "section": "22.2 Deep Sleep code",
    "text": "22.2 Deep Sleep code\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n#define uS_TO_S_FACTOR 1000000ULL  /* Conversion factor for micro seconds to seconds */\n#define TIME_TO_SLEEP  10        /* Time ESP32 will go to sleep (in seconds) */\n\n\nvoid setup(){\n  Serial.begin(115200);\n  Serial.println(\"Good morning!\");\n  delay(2000); //Take some time to open up the Serial Monitor\n\n  // turn on LED\n  Serial.println(\"turn on LED\");\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, HIGH);\n  delay(2000); //Take some time to open up the Serial Monitor\n\n  /*\n  First we configure the wake up source\n  We set our ESP32 to wake up every TIME_TO_SLEEP seconds\n  */\n  esp_sleep_enable_timer_wakeup(TIME_TO_SLEEP * uS_TO_S_FACTOR);\n  Serial.println(\"Setup ESP32 to sleep for every \" + String(TIME_TO_SLEEP) +\n  \" Seconds\");\n\n  \n  Serial.println(\"Going to sleep now\");\n  Serial.flush(); \n  esp_deep_sleep_start();\n  Serial.println(\"This will never be printed\");\n}\n\nvoid loop(){\n  //This is not going to be called\n}"
  },
  {
    "objectID": "tutorials/deep_sleep.html#deep-sleep-wake-with-touch",
    "href": "tutorials/deep_sleep.html#deep-sleep-wake-with-touch",
    "title": "22  Deep Sleep",
    "section": "22.3 Deep Sleep wake with touch",
    "text": "22.3 Deep Sleep wake with touch\nAdapted from here.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n/*\nDeep Sleep with Touch Wake Up\n=====================================\nThis code displays how to use deep sleep with\na touch as a wake up source and how to store data in\nRTC memory to use it over reboots\n\nESP32 can have multiple touch pads enabled as wakeup source\nESP32-S2 and ESP32-S3 supports only 1 touch pad as wakeup source enabled\n\nThis code is under Public Domain License.\n\nAuthor:\nPranav Cherukupalli &lt;cherukupallip@gmail.com&gt;\n*/\n\n#if CONFIG_IDF_TARGET_ESP32\n#define THRESHOLD 40   /* Greater the value, more the sensitivity */\n#else                  //ESP32-S2 and ESP32-S3 + default for other chips (to be adjusted) */\n#define THRESHOLD 5000 /* Lower the value, more the sensitivity */\n#endif\n\nRTC_DATA_ATTR int bootCount = 0;\ntouch_pad_t touchPin;\n/*\nMethod to print the reason by which ESP32\nhas been awaken from sleep\n*/\nvoid print_wakeup_reason() {\n  esp_sleep_wakeup_cause_t wakeup_reason;\n\n  wakeup_reason = esp_sleep_get_wakeup_cause();\n\n  switch (wakeup_reason) {\n    case ESP_SLEEP_WAKEUP_EXT0:     Serial.println(\"Wakeup caused by external signal using RTC_IO\"); break;\n    case ESP_SLEEP_WAKEUP_EXT1:     Serial.println(\"Wakeup caused by external signal using RTC_CNTL\"); break;\n    case ESP_SLEEP_WAKEUP_TIMER:    Serial.println(\"Wakeup caused by timer\"); break;\n    case ESP_SLEEP_WAKEUP_TOUCHPAD: Serial.println(\"Wakeup caused by touchpad\"); break;\n    case ESP_SLEEP_WAKEUP_ULP:      Serial.println(\"Wakeup caused by ULP program\"); break;\n    default:                        Serial.printf(\"Wakeup was not caused by deep sleep: %d\\n\", wakeup_reason); break;\n  }\n}\n\n/*\nMethod to print the touchpad by which ESP32\nhas been awaken from sleep\n*/\nvoid print_wakeup_touchpad() {\n  touchPin = esp_sleep_get_touchpad_wakeup_status();\n\n#if CONFIG_IDF_TARGET_ESP32\n  switch (touchPin) {\n    case 0:  Serial.println(\"Touch detected on GPIO 4\"); break;\n    case 1:  Serial.println(\"Touch detected on GPIO 0\"); break;\n    case 2:  Serial.println(\"Touch detected on GPIO 2\"); break;\n    case 3:  Serial.println(\"Touch detected on GPIO 15\"); break;\n    case 4:  Serial.println(\"Touch detected on GPIO 13\"); break;\n    case 5:  Serial.println(\"Touch detected on GPIO 12\"); break;\n    case 6:  Serial.println(\"Touch detected on GPIO 14\"); break;\n    case 7:  Serial.println(\"Touch detected on GPIO 27\"); break;\n    case 8:  Serial.println(\"Touch detected on GPIO 33\"); break;\n    case 9:  Serial.println(\"Touch detected on GPIO 32\"); break;\n    default: Serial.println(\"Wakeup not by touchpad\"); break;\n  }\n#else\n  if (touchPin &lt; TOUCH_PAD_MAX) {\n    Serial.printf(\"Touch detected on GPIO %d\\n\", touchPin);\n  } else {\n    Serial.println(\"Wakeup not by touchpad\");\n  }\n#endif\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(1000);  //Take some time to open up the Serial Monitor\n\n  //Increment boot number and print it every reboot\n  ++bootCount;\n  Serial.println(\"Boot number: \" + String(bootCount));\n\n  //Print the wakeup reason for ESP32 and touchpad too\n  print_wakeup_reason();\n  print_wakeup_touchpad();\n\n#if CONFIG_IDF_TARGET_ESP32\n  //Setup sleep wakeup on Touch Pad 3 + 7 (GPIO15 + GPIO 27)\n  touchSleepWakeUpEnable(T3, THRESHOLD);\n  touchSleepWakeUpEnable(T7, THRESHOLD);\n\n#else  //ESP32-S2 + ESP32-S3\n  //Setup sleep wakeup on Touch Pad 3 (GPIO3)\n  touchSleepWakeUpEnable(T3, THRESHOLD);\n\n#endif\n\n  //Go to sleep now\n  Serial.println(\"Going to sleep now\");\n  esp_deep_sleep_start();\n  Serial.println(\"This will never be printed\");\n}\n\nvoid loop() {\n  //This will never be reached\n}"
  },
  {
    "objectID": "tutorials/deep_sleep.html#save-values-between-sleeps",
    "href": "tutorials/deep_sleep.html#save-values-between-sleeps",
    "title": "22  Deep Sleep",
    "section": "22.4 Save values between sleeps",
    "text": "22.4 Save values between sleeps\nRecommended tutorial here.\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n/*\nGood tutorial\nhttps://randomnerdtutorials.com/esp32-save-data-permanently-preferences/\n*/\n#include &lt;Preferences.h&gt; // Include the Preferences library\n\n#define uS_TO_S_FACTOR 1000000ULL  /* Conversion factor for microseconds to seconds */\n#define TIME_TO_SLEEP  10          /* Time ESP32 will go to sleep (in seconds) */\n\nPreferences preferences;           // Create a Preferences object\n\nvoid setup() {\n  Serial.begin(115200);\n  Serial.println(\"Good morning!\");\n  delay(100); // Take some time to open up the Serial Monitor\n\n  // Turn on LED\n  Serial.println(\"Turn on LED\");\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, HIGH);\n  delay(2000);\n\n  // Open Preferences in RW mode\n  preferences.begin(\"my-app\", false); // \"my-app\" is the namespace, false = read/write mode\n\n  // Retrieve stored values\n  int storedInt = preferences.getInt(\"myInt\", 0);      // Default value is 0 if not set\n  float storedFloat = preferences.getFloat(\"myFloat\", 0.0); // Default is 0.0\n  String storedString = preferences.getString(\"myString\", \"Default\");\n\n  Serial.println(\"Retrieved values from flash:\");\n  Serial.println(\"Int: \" + String(storedInt));\n  Serial.println(\"Float: \" + String(storedFloat));\n  Serial.println(\"String: \" + storedString);\n\n  // Increment and store new values\n  storedInt++;\n  storedFloat += 1.5;\n  storedString = \"Wake #\" + String(storedInt);\n\n  preferences.putInt(\"myInt\", storedInt);\n  preferences.putFloat(\"myFloat\", storedFloat);\n  preferences.putString(\"myString\", storedString);\n\n  Serial.println(\"Stored updated values in flash:\");\n  Serial.println(\"Int: \" + String(storedInt));\n  Serial.println(\"Float: \" + String(storedFloat));\n  Serial.println(\"String: \" + storedString);\n\n  // Close Preferences\n  preferences.end();\n\n  // Configure the wake-up source\n  esp_sleep_enable_timer_wakeup(TIME_TO_SLEEP * uS_TO_S_FACTOR);\n  Serial.println(\"Setup ESP32 to sleep for every \" + String(TIME_TO_SLEEP) + \" seconds\");\n\n  Serial.println(\"Going to sleep now\");\n  Serial.flush();\n  esp_deep_sleep_start();\n\n  Serial.println(\"This will never be printed\");\n}\n\nvoid loop() {\n  // This is not going to be called\n}"
  },
  {
    "objectID": "tutorials/esp_now.html#find-what-the-receiver-mac-address-is",
    "href": "tutorials/esp_now.html#find-what-the-receiver-mac-address-is",
    "title": "23  ESP-NOW",
    "section": "23.1 Find what the receiver MAC address is",
    "text": "23.1 Find what the receiver MAC address is\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n// Complete Instructions to Get and Change ESP MAC Address: https://RandomNerdTutorials.com/get-change-esp32-esp8266-mac-address-arduino/\n\n#ifdef ESP32\n  #include &lt;WiFi.h&gt;\n#else\n  #include &lt;ESP8266WiFi.h&gt;\n#endif\n\nvoid setup(){\n  Serial.begin(115200);\n  Serial.println();\n  Serial.print(\"ESP Board MAC Address:  \");\n  Serial.println(WiFi.macAddress());\n}\n \nvoid loop(){\n\n}"
  },
  {
    "objectID": "tutorials/esp_now.html#sender-code",
    "href": "tutorials/esp_now.html#sender-code",
    "title": "23  ESP-NOW",
    "section": "23.2 Sender code",
    "text": "23.2 Sender code\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n/*********\n  Rui Santos\n  Complete project details at https://RandomNerdTutorials.com/esp-now-many-to-one-esp32/\n  \n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files.\n  \n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n*********/\n\n#include &lt;esp_now.h&gt;\n#include &lt;WiFi.h&gt;\n\n// REPLACE WITH THE RECEIVER'S MAC Address\n// This is the slave MAC address\n// 40:22:D8:66:8E:2C\n// this is how you have to write it\nuint8_t broadcastAddress[] = {0x40, 0x22, 0xD8, 0x66, 0x8E, 0x2C};\n\n// Structure example to send data\n// Must match the receiver structure\ntypedef struct struct_message {\n    int id; // must be unique for each sender board\n    int x;\n    int y;\n} struct_message;\n\n// Create a struct_message called myData\nstruct_message myData;\n\n// Create peer interface\nesp_now_peer_info_t peerInfo;\n\n// callback when data is sent\nvoid OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {\n  Serial.print(\"\\r\\nLast Packet Send Status:\\t\");\n  Serial.println(status == ESP_NOW_SEND_SUCCESS ? \"Delivery Success\" : \"Delivery Fail\");\n}\n \nvoid setup() {\n  // Init Serial Monitor\n  Serial.begin(115200);\n\n  // Set device as a Wi-Fi Station\n  WiFi.mode(WIFI_STA);\n\n  // Init ESP-NOW\n  if (esp_now_init() != ESP_OK) {\n    Serial.println(\"Error initializing ESP-NOW\");\n    return;\n  }\n\n  // Once ESPNow is successfully Init, we will register for Send CB to\n  // get the status of Trasnmitted packet\n  esp_now_register_send_cb(OnDataSent);\n  \n  // Register peer\n  memcpy(peerInfo.peer_addr, broadcastAddress, 6);\n  peerInfo.channel = 0;  \n  peerInfo.encrypt = false;\n  \n  // Add peer        \n  if (esp_now_add_peer(&peerInfo) != ESP_OK){\n    Serial.println(\"Failed to add peer\");\n    return;\n  }\n}\n \nvoid loop() {\n  // Set values to send\n  myData.id = 1;\n  myData.x = write here an integer number you like //random(0,50);\n  myData.y = write here an integer number you like //random(0,50);\n\n  // Send message via ESP-NOW\n  esp_err_t result = esp_now_send(broadcastAddress, (uint8_t *) &myData, sizeof(myData));\n   \n  if (result == ESP_OK) {\n    Serial.println(\"Sent with success\");\n  }\n  else {\n    Serial.println(\"Error sending the data\");\n  }\n  delay(10000);\n}"
  },
  {
    "objectID": "tutorials/esp_now.html#receiver-code",
    "href": "tutorials/esp_now.html#receiver-code",
    "title": "23  ESP-NOW",
    "section": "23.3 Receiver code",
    "text": "23.3 Receiver code\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n#include &lt;esp_now.h&gt;\n#include &lt;WiFi.h&gt;\n\n// Structure example to receive data\n// Must match the sender structure\ntypedef struct struct_message {\n  int id;\n  int x;\n  int y;\n}struct_message;\n\n// Create a struct_message called myData\nstruct_message myData;\n\n// Create a structure to hold the readings from each board\nstruct_message board1;\nstruct_message board2;\nstruct_message board3;\n\n// Create an array with all the structures\nstruct_message boardsStruct[3] = {board1, board2, board3};\n\n// callback function that will be executed when data is received\nvoid OnDataRecv(const uint8_t * mac_addr, const uint8_t *incomingData, int len) {\n  char macStr[18];\n  Serial.print(\"Packet received from: \");\n  snprintf(macStr, sizeof(macStr), \"%02x:%02x:%02x:%02x:%02x:%02x\",\n           mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);\n  Serial.println(macStr);\n  memcpy(&myData, incomingData, sizeof(myData));\n  Serial.printf(\"Board ID %u: %u bytes\\n\", myData.id, len);\n  // Update the structures with the new incoming data\n  boardsStruct[myData.id-1].x = myData.x;\n  boardsStruct[myData.id-1].y = myData.y;\n  Serial.printf(\"x value: %d \\n\", boardsStruct[myData.id-1].x);\n  Serial.printf(\"y value: %d \\n\", boardsStruct[myData.id-1].y);\n  Serial.println();\n}\n \nvoid setup() {\n  //Initialize Serial Monitor\n  Serial.begin(115200);\n  \n  //Set device as a Wi-Fi Station\n  WiFi.mode(WIFI_STA);\n\n  //Init ESP-NOW\n  if (esp_now_init() != ESP_OK) {\n    Serial.println(\"Error initializing ESP-NOW\");\n    return;\n  }\n  \n  // Once ESPNow is successfully Init, we will register for recv CB to\n  // get recv packer info\n  esp_now_register_recv_cb(OnDataRecv);\n}\n \nvoid loop() {\n  // Acess the variables for each board\n  /*int board1X = boardsStruct[0].x;\n  int board1Y = boardsStruct[0].y;\n  int board2X = boardsStruct[1].x;\n  int board2Y = boardsStruct[1].y;\n  int board3X = boardsStruct[2].x;\n  int board3Y = boardsStruct[2].y;*/\n\n  delay(10000);  \n}"
  },
  {
    "objectID": "tutorials/OLED.html#oled-code",
    "href": "tutorials/OLED.html#oled-code",
    "title": "24  OLED screen",
    "section": "24.1 OLED code",
    "text": "24.1 OLED code\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n#include &lt;Wire.h&gt;\n#include &lt;U8g2lib.h&gt;\n\n// Initialize the display (change constructor according to your OLED model)\nU8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);\n\nvoid setup() {\n  // initialize the display\n  u8g2.begin();\n  \n  // display a startup message\n  u8g2.clearBuffer();                // clear the internal memory\n\n    // Small text\n  u8g2.setFont(u8g2_font_6x10_tr);\n  u8g2.drawStr(3, 10, \"S-Hello\");\n\n  // Medium text\n  u8g2.setFont(u8g2_font_ncenB08_tr);\n  u8g2.drawStr(3, 30, \"M-Hello\");\n\n  // Large text\n  u8g2.setFont(u8g2_font_fur20_tr);\n  u8g2.drawStr(3, 60, \"L-Hello\");\n\n  // transfer buffer to the display\n  u8g2.sendBuffer();      \n  \n  delay(5000); // wait \n}\n\nvoid loop() {\n  static int counter = 0;\n  \n  // update the screen\n  u8g2.clearBuffer();\n  u8g2.setFont(u8g2_font_ncenB08_tr); // choose a suitable font\n  u8g2.drawStr(3, 16, \"Counter:\");\n  u8g2.drawStr(73, 16, String(counter).c_str());\n  u8g2.sendBuffer();\n  \n  // increment the counter\n  counter++;\n  \n  // wait for 1 second\n  delay(1000);\n}"
  },
  {
    "objectID": "tutorials/python-matlab-basics.html#matlab",
    "href": "tutorials/python-matlab-basics.html#matlab",
    "title": "25  Basic Data Analysis with Python and Matlab",
    "section": "25.1 Matlab",
    "text": "25.1 Matlab\nMatlab is a proprietary (paid) software, but all HUJI students can install it and use it for free as long as they are connected to the university’s internet, either directly or through a VPN. In any case, we will be using Matlab to plot graphs on Thingspeak, which is owned by the same parent company, MathWorks.\nHere are a few very useful tutorials provided by MathWorks:\n\nApps\nAnalyze Your Data\nPrepare and Analyze Data — Examples\nVisualize Data — Examples\nAct on Data — Examples\n\nAs a first example that we will run together, please follow the steps below:\n\nLog into Thingspeak, open your channel, and then go to either Private View or Public View.\nPress on MATLAB Visualization box, on the top right.\nFrom Templates, choose Create a 2-D line plot, then press Create.\nIn case the template doesn’t load, you can create a custom visualization and paste the code below\n\n% Template MATLAB code for visualizing data from a channel as a 2D line\n% plot using PLOT function.\n\n% Prior to running this MATLAB code template, assign the channel variables.\n% Set 'readChannelID' to the channel ID of the channel to read from. \n% Also, assign the read field ID to 'fieldID1'. \n\n% TODO - Replace the [] with channel ID to read data from:\nreadChannelID = [];\n% TODO - Replace the [] with the Field ID to read data from:\nfieldID1 = [];\n\n% Channel Read API Key \n% If your channel is private, then enter the read API\n% Key between the '' below: \nreadAPIKey = '';\n\n%% Read Data %%\n\n[data, time] = thingSpeakRead(readChannelID, 'Field', fieldID1, 'NumPoints', 30, 'ReadKey', readAPIKey);\n\n%% Visualize Data %%\n\nplot(time, data);\nRead here more about arguments that function thingSpeakRead can receive"
  },
  {
    "objectID": "tutorials/python-matlab-basics.html#python",
    "href": "tutorials/python-matlab-basics.html#python",
    "title": "25  Basic Data Analysis with Python and Matlab",
    "section": "25.2 Python",
    "text": "25.2 Python\nWe will be using Jupyter Notebook as our python interface. There are many ways of running python, we chose Jupyter because it allows for easy prototyping, and the Markdown cells are great for documentation.\nJupyter Notebook{: .button}"
  },
  {
    "objectID": "tutorials/API-thingspeak-python.html#import-relevant-packages",
    "href": "tutorials/API-thingspeak-python.html#import-relevant-packages",
    "title": "26  API to download Thingspeak data with Python",
    "section": "26.1 Import relevant packages",
    "text": "26.1 Import relevant packages\n\nimport urllib\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport matplotlib.dates as mdates"
  },
  {
    "objectID": "tutorials/API-thingspeak-python.html#download-data-from-thingspeak-and-save-them-to-file",
    "href": "tutorials/API-thingspeak-python.html#download-data-from-thingspeak-and-save-them-to-file",
    "title": "26  API to download Thingspeak data with Python",
    "section": "26.2 Download data from Thingspeak and save them to file",
    "text": "26.2 Download data from Thingspeak and save them to file\n\n# define what to download\nchannels = \"2076217\"\nfields = \"1,2,3\"\n\n# see here all the \"Query String Parameters\"\n# https://www.mathworks.com/help/thingspeak/readdata.html\n\nresults = 100\n# Download the last N results\n# url = f\"https://api.thingspeak.com/channels/{channels}/fields/{fields}.csv?results={results}\"\n\nminutes = \"30\"\n# Number of minutes before NOW to include in response.\n# url = f\"https://api.thingspeak.com/channels/{channels}/fields/{fields}.csv?minutes={minutes}\"\n\nstart = \"2023-04-16%2000:00:00\"  # format YYYY-MM-DD%20HH:NN:SS\nend = \"2023-04-19%2000:00:00\"    # format YYYY-MM-DD%20HH:NN:SS\nurl = f\"https://api.thingspeak.com/channels/{channels}/fields/{fields}.csv?start={start}&end={end}\"\n\n# Open the URL and get the response\ndata = urllib.request.urlopen(url)\n# Read the response data\nd = data.read()\n# save data to csv\nfilename1 = \"downloaded_data.csv\"\nfile = open(filename1, \"w\")\nfile.write(d.decode('UTF-8'))\nfile.close()"
  },
  {
    "objectID": "tutorials/API-thingspeak-python.html#load-data-as-a-pandas-dataframe",
    "href": "tutorials/API-thingspeak-python.html#load-data-as-a-pandas-dataframe",
    "title": "26  API to download Thingspeak data with Python",
    "section": "26.3 Load data as a pandas dataframe",
    "text": "26.3 Load data as a pandas dataframe\n\n# load data\ndf = pd.read_csv(filename1)\n# rename columns\ndf = df.rename(columns={\"created_at\": \"timestamp\",\n                        \"field1\": \"Temp\",\n                        \"field2\": \"RH\",\n                        \"field3\": \"VPD\",\n                        # \"field4\": \"whatever\",\n                        })\n# set timestamp as index\ndf['timestamp'] = pd.to_datetime(df['timestamp'])\ndf = df.set_index('timestamp')\ndf\n\n\n\n\n\n\n\n\nentry_id\nTemp\nRH\nVPD\n\n\ntimestamp\n\n\n\n\n\n\n\n\n2023-04-16 00:01:20+00:00\n3892\n21.59\n72.31\n0.71442\n\n\n2023-04-16 00:06:22+00:00\n3893\n21.60\n72.14\n0.71925\n\n\n2023-04-16 00:11:24+00:00\n3894\n21.59\n72.38\n0.71262\n\n\n2023-04-16 00:16:25+00:00\n3895\n21.59\n71.86\n0.72603\n\n\n2023-04-16 00:21:27+00:00\n3896\n21.54\n71.49\n0.73333\n\n\n...\n...\n...\n...\n...\n\n\n2023-04-18 18:58:48+00:00\n4691\n23.93\n55.29\n1.32931\n\n\n2023-04-18 19:03:50+00:00\n4692\n23.98\n55.25\n1.33450\n\n\n2023-04-18 19:08:52+00:00\n4693\n23.92\n55.07\n1.33505\n\n\n2023-04-18 19:13:53+00:00\n4694\n23.92\n59.84\n1.19332\n\n\n2023-04-18 19:18:17+00:00\n4695\n23.92\n57.23\n1.27087\n\n\n\n\n804 rows × 4 columns"
  },
  {
    "objectID": "tutorials/API-thingspeak-python.html#plot-data",
    "href": "tutorials/API-thingspeak-python.html#plot-data",
    "title": "26  API to download Thingspeak data with Python",
    "section": "26.4 Plot data",
    "text": "26.4 Plot data\nNow you can manipulate your data however you want! Here we will simply plot one of the fields.\n\nfig, ax = plt.subplots(1)\nax.plot(df['Temp'])\nax.set(ylabel=\"temperature (°C)\")\nplt.gcf().autofmt_xdate()  # makes slanted dates"
  },
  {
    "objectID": "tutorials/water-and-energy-balances.html#water-balance",
    "href": "tutorials/water-and-energy-balances.html#water-balance",
    "title": "27  Water and Energy Balances",
    "section": "27.1 Water balance",
    "text": "27.1 Water balance\nA useful source is Nadia Christina Sabeh’s PhD thesis, 2007.\n\n\\[\nE_V + E_C + E_S + E_T = 0\n\\]"
  },
  {
    "objectID": "tutorials/water-and-energy-balances.html#energy-balance",
    "href": "tutorials/water-and-energy-balances.html#energy-balance",
    "title": "27  Water and Energy Balances",
    "section": "27.2 Energy balance",
    "text": "27.2 Energy balance\n\n\\[\nQ_R + Q_G + Q_V + Q_S + Q_P + Q_L + Q_H = 0\n\\]"
  },
  {
    "objectID": "tutorials/water-and-energy-balances.html#evaporative-cooling",
    "href": "tutorials/water-and-energy-balances.html#evaporative-cooling",
    "title": "27  Water and Energy Balances",
    "section": "27.3 Evaporative Cooling",
    "text": "27.3 Evaporative Cooling"
  },
  {
    "objectID": "tutorials/water-and-energy-balances.html#potential-evapotranspiration",
    "href": "tutorials/water-and-energy-balances.html#potential-evapotranspiration",
    "title": "27  Water and Energy Balances",
    "section": "27.4 Potential Evapotranspiration",
    "text": "27.4 Potential Evapotranspiration\n\n27.4.1 Penman (1948)\nThis equation accounts for two main terms: * the first is the available energy flux density, * the second term is the drying power of the air.\n\\[\nPE = \\frac{\\Delta(R_n-G) + \\gamma\\cdot 2.6 (1+0.536 u_2)\\text{VPD}}{\\lambda(\\Delta+\\gamma)}\n\\]\nMore about this here.\n\n\n27.4.2 PyET\nLuckily, we don’t have to work very hard to estimate the potential evapotranspiration. We will use the Python library pyet:\n\ndocumentation\ngithub\n\nUsing PyET is quite straightforward:\npyet.pm_fao56(tmean,               # mean temperature\n              wind,                # wind speed\n              rn=rn,               # net radiation\n              tmax=tmax,           # max temperature\n              tmin=tmin,           # max temperature\n              rh=rh,               # relative humidity\n              elevation=elevation) # elevation above sea level"
  },
  {
    "objectID": "tutorials/psychrometric-chart-and-evaporative-cooling.html#psychrometric-chart",
    "href": "tutorials/psychrometric-chart-and-evaporative-cooling.html#psychrometric-chart",
    "title": "28  Psychrometric Chart and Evaporative Cooling",
    "section": "28.1 Psychrometric Chart",
    "text": "28.1 Psychrometric Chart\n\n\n\nChart\n\n\nHi-res pdf of the graph above.\nThe chart allows us to study the relation between:\n\nAir temperature\nRelative humidity\nDew point\nWet bulb temperature\nMoisture content\nEnthalpy\nAir volume\n\nYou can read more about all of these here.\nInformation about how to read the chart can be found here."
  },
  {
    "objectID": "tutorials/psychrometric-chart-and-evaporative-cooling.html#evaporative-cooling-wiki",
    "href": "tutorials/psychrometric-chart-and-evaporative-cooling.html#evaporative-cooling-wiki",
    "title": "28  Psychrometric Chart and Evaporative Cooling",
    "section": "28.2 Evaporative cooling (wiki)",
    "text": "28.2 Evaporative cooling (wiki)\nEvaporative coolers lower the temperature of air using the principle of evaporative cooling. Evaporative cooling is the conversion of liquid water into vapor using the thermal energy in the air, resulting in a lower air temperature. The energy needed to evaporate the water is taken from the air in the form of sensible heat, which affects the temperature of the air, and converted into latent heat, the energy present in the water vapor component of the air, whilst the air remains at a constant enthalpy value. This conversion of sensible heat to latent heat is known as an isenthalpic process because it occurs at a constant enthalpy value. Evaporative cooling therefore causes a drop in the temperature of air proportional to the sensible heat drop and an increase in humidity proportional to the latent heat gain. Evaporative cooling can be visualized using a psychrometric chart by finding the initial air condition and moving along a line of constant enthalpy toward a state of higher humidity\nIn the green house we have an evaporative cooler as shown in this diagram:\n \nWater trickles on a celullose pad, then fans push dry air from outside through the pad in which water evaporates and the air gets colder and humidity rises."
  },
  {
    "objectID": "tutorials/psychrometric-chart-and-evaporative-cooling.html#how-much-can-the-cooler-cool",
    "href": "tutorials/psychrometric-chart-and-evaporative-cooling.html#how-much-can-the-cooler-cool",
    "title": "28  Psychrometric Chart and Evaporative Cooling",
    "section": "28.3 How much can the cooler cool?",
    "text": "28.3 How much can the cooler cool?\nThe evaporative cooler can cool as low as the “wet bulb trmperature”.\nWe can look at the chart, and we should for the first time… But let’s calculate it using the PschroLib python package.\nAll the library’s functions can be found here.\nimport psychrolib\n\n# Set the unit system, for example to SI (can be either SI or IP) - this needs to be done only once\npsychrolib.SetUnitSystem(psychrolib.SI)\n\naltitude = 0\natm_pressure = psychrolib.GetStandardAtmPressure(0)\n\n# Calculate the wet bulb temperature for a dry bulb temperature of 25 C , a relative humidity of 80% and atmospheric pressure (kPa)\nWBT = psychrolib.GetTWetBulbFromRelHum(25.0, 0.80,atm_pressure )\nprint(f'Wet Bulb Temperature: {WBT:.3f} degree C')\nprint(f'Degrees cooled: {25-WBT:.3f} degree C')\nOutput:\nWet Bulb Temperature: 22.380 degree C\nDegrees cooled: 2.620 degree C\nNow let’s see how many degrees will it cool if we have only 30% relative humidity outside:\nWBT = psychrolib.GetTWetBulbFromRelHum(25.0, 0.30,atm_pressure )\nprint(f'Wet Bulb Temperature: {WBT:.3f} degree C')\nprint(f'Degrees cooled: {25-WBT:.3f} degree C')\nOutput:\nWet Bulb Temperature: 14.422 degree C\nDegrees cooled: 10.578 degree C\nAs you can see it is much more efficient in dry areas like deserts. Therefore it is many times called a “desert cooler”. What will the relative humidity be for the air that leaves the pad?\n\n28.3.1 Efficiency\nTheoretically, an evaporative cooler cools down to the wet bulb temperature, but in reality it is not 100% efficient and the air comes out not as cold. Many factors can influence: water quality, air speed, pad thickness, pad condition (you will se that ours is not great…), etc. We can calculate the efficiency by this equation:\n\\[\n\\eta = \\dfrac{T_i-T_o}{T_i-T_w},\n\\]\nwhere\n\n\\(T_i = \\:\\) temperature coming into the pad.\n\n\\(T_o = \\:\\) temperature coming out of the pad.\n\\(T_w = \\:\\) wet bulb temperature.\n\nWe can calculate it using data from our sensors and learn about the greenhouse we are using.\nFor example:\nIf we measure 30C and 60% humidity outside and the temperature out of the pad is 26C\nT_i = 30\nT_o = 26\nT_w = psychrolib.GetTWetBulbFromRelHum(T_i, 0.60,atm_pressure )\nprint(f'Wet Bulb Temperature: {T_w:.3f} degree C')\n\neffi = (T_i-T_o)/(T_i-T_w)\nprint(f'Efficiency is: {100*effi:.3f} %')\nOutput:\nWet Bulb Temperature: 23.812 degree C\nEfficiency is: 64.646 %\n\n\n28.3.2 What else can we calculate?\nKnowing the fan’s capacity (we can measure that too using wind sensors) and the temerature and humidity of the air leaving the greenhouse we can calculate:\n\nAmount of water evaporated from the pad,\nAmount of water evaporated from the greenhouse (being a concreete greenhouse that means total evaporation from plants and pots),\nHeat removed from the greenouse by the flowing air,\n\nThese are just some ideas, you can think of other interesting things to calculate.\nThere are existing models for predicting the temperatures of greenhouses. There are many other factors taking place such as solar radiation, outside wind, amounts of plants in the greenhouse, etc. We won’t be studying those here, but maybe you can come up with some models/conclusions/correlations of your own :)"
  },
  {
    "objectID": "assignments/submission_info.html",
    "href": "assignments/submission_info.html",
    "title": "29  Submission Guidelines",
    "section": "",
    "text": "Unless stated otherwise, every assignment should be submitted according to the following guidelines:\n\nUpload code and supporting materials (such as schematics, wiring diagrams, etc.) to Moodle.\nUsing the Google Form linked in the Moodle assignment, upload a short video (up to 2 minutes) showing the following:\n\nThe hardware you built\n\nThe software you wrote (e.g., running code, interface, or serial output)\n\nA short demonstration showing that it works\n\nYou in the video (so we can confirm it’s your work)\n\nYou should speak throughout the video and explain what we’re seeing.\n\n\nBelow is an example video:\n\n \n\n\n⚠️ Note: The video does not need to be edited or polished. A simple recording from your phone is perfect. The goal is to show that your system works and that you understand what you’ve built — not to create a fancy production."
  },
  {
    "objectID": "assignments/assignment1.html",
    "href": "assignments/assignment1.html",
    "title": "30  Assignment 1",
    "section": "",
    "text": "First, read the submission guidelines.\nYou will write Arduino code that incorporates all the following elements learned in First programs. Upload your .ino file on the course’s Moodle page, You’ll have two weeks until deadline.\n\nvariable declaration, e.g.\nfloat my_var=1.23;\nint i, j;\nfunction declaration, e.g.\nint my_sum(int x, int y) {\n  return x + y;\n}\nBuilt-in and external LED control (external LED will be learned in week 2)\nConditionals, e.g.\nif (temperature &gt; 30.0) {\n  fan = 1;\n} else {\n  fan = 0;\n}\nRandom numbers, e.g.\n// random number from -5 (inclusive) to +5 (exclusive)\nrand1 = random(-5, 5);\nSerial plotting, numbers and text\nSerial read\nComments explaining every step of what you did\nBonus: connect to WiFi and make use of time from the internet (learned in week 2)\nObligatory: at the very top of your code, write in many lines an explanation (in English) of what your code does\n\n/*\nAuthor: Harry Potter\nClass: Agrotech Lab\nDate: 2023-03-14\nThis code does bla bla bla.\nMore explanations here.\n*/"
  },
  {
    "objectID": "assignments/assignment2.html",
    "href": "assignments/assignment2.html",
    "title": "31  Assignment 2",
    "section": "",
    "text": "Create a small project where you control an output device (such as LEDs, relays, etc.) based on changes in an input, like temperature or humidity readings.\nBonus: Include LED brightness control using PWM.\nThis assignment is basically the Challenges section from the lecture on control.\nUpload the .ino file, ensuring you include a few lines of comments at the beginning of the code to explain what the project does."
  },
  {
    "objectID": "resources.html#iconify-mdi-led-on-equipment",
    "href": "resources.html#iconify-mdi-led-on-equipment",
    "title": "32   Resources",
    "section": "32.1  Equipment",
    "text": "32.1  Equipment\n\n32.1.1 Equipment Pickup Form\n\nPlease fill out this form every time you receive a new sensor or equipment. You will need to provide your 9-digit ID number and indicate which sensor(s) you have received.\nMake sure your name and phone number are written on the box containing the equipment.\nBy filling out this form, you agree to receive the item(s) and are obligated to return them at the end of the course.\nIf you’re not sure, click here to check which equipment you borrowed from the course.\n\n\n32.1.1.0.1 Do you want to order equipment for yourself?\nClick for a list of the main components used in this course."
  },
  {
    "objectID": "resources.html#iconify-akar-icons-github-fill-github",
    "href": "resources.html#iconify-akar-icons-github-fill-github",
    "title": "32   Resources",
    "section": "32.2  Github",
    "text": "32.2  Github\nMake an account on Github. Create a repository called “agrotech” or whatever you else want to call it. You can upload to this repository your code, data, diagrams, pictures, markdown, etc. In the end of the semester you will upload your project report as a Jupyter Notebook file.\nFrom now on, your main Github page can be your “geek face” on the internet. Make a clean and simple readme.md, telling the world who you are and what you do."
  },
  {
    "objectID": "resources.html#iconify-simple-icons-jupyter-jupyter-notebook",
    "href": "resources.html#iconify-simple-icons-jupyter-jupyter-notebook",
    "title": "32   Resources",
    "section": "32.3  Jupyter Notebook",
    "text": "32.3  Jupyter Notebook\nThe easiest way to install Python (+ Jupyter Notebook, Spyder, PyCharm, JupyterLab, etc) on any OS is to download Anaconda. Jupyter Notebook is a versatile environment that allows you to write code and documentation in one single file, taking advantage of Markdown. Click for a short and a long markdown cheat sheet."
  },
  {
    "objectID": "resources.html#iconify-eos-icons-hardware-circuit-fritzing",
    "href": "resources.html#iconify-eos-icons-hardware-circuit-fritzing",
    "title": "32   Resources",
    "section": "32.4  Fritzing",
    "text": "32.4  Fritzing\nFritzing is a nice software that lets you easily draw your own circuits and diagrams."
  },
  {
    "objectID": "resources.html#iconify-akar-icons-link-chain-useful-links",
    "href": "resources.html#iconify-akar-icons-link-chain-useful-links",
    "title": "32   Resources",
    "section": "32.5  Useful links",
    "text": "32.5  Useful links\nThe world of MCUs has great support online. You actually don’t need this course to learn it… We are only here to guide you and help with the first steps. SO below are some usful links to websites/Youtube channels that provide excellent information:\nArduino syntax and coding:\n\nArduino — Language Reference\n\nTutorials by sensor manufacturers:\n\nSparkfun\n\nAdafruit\n\nProject ideas:\n\nArduino Project Hub\n\nInstructables — Arduino\n\nArduino beginners course:\n\nPaul McWhorter - New Arduino Tutorials\n\nExamples of good Youtube channels:\n\nAndreas Spiess\n\nG6EJD - David\n\nGreatScott!\n\neduc8s.tv\n\nOregon State’s OPEnS Lab\n\nGithub"
  },
  {
    "objectID": "projects.html#final-projects",
    "href": "projects.html#final-projects",
    "title": "33   Past Final Projects",
    "section": "33.1 2024–25 Final projects",
    "text": "33.1 2024–25 Final projects"
  },
  {
    "objectID": "projects.html#final-projects-1",
    "href": "projects.html#final-projects-1",
    "title": "33   Past Final Projects",
    "section": "33.2 2023–24 Final projects",
    "text": "33.2 2023–24 Final projects\n\n\n\nTeam\nProject\n\n\n\n\n   Gabi Harel, Yoav Abeyv, Rotem Porat\nMonitoring Microbial Metabolism\n\n\n   Ella Faruchi, Rotem David, Matar Tal, Asif Charazi\nThe Eggs-periment\n\n\n   Gil Lifshitz, Matar Shema\nBaby Sensor\n\n\n   Neta Cohen Simhi, Omer Meyer, Itai David, Aya Even Dar\nCompost Monitoring System\n\n\n   Gali Shaani, Yonatan Schwartz\nSeed counter"
  },
  {
    "objectID": "projects.html#final-projects-2",
    "href": "projects.html#final-projects-2",
    "title": "33   Past Final Projects",
    "section": "33.3 2022–23 Final projects",
    "text": "33.3 2022–23 Final projects\n\n\n\nTeam\nProject\n\n\n\n\n   Aviv Tzafrir, Daniel Shiller, Guy Dabby\nHydroponic system\n\n\n   Orel Suliman, Yotam Menachem\nGreeny - Plant-propagation-GreenHouse\n\n\n   Guy Brauner, Victoria Sholohov, Shir Avraham\nHumidity control\n\n\n   Eliraz Shomron\nPlant water system management\n\n\n   Yovel Rodoy\nmeteorological station\n\n\n   Yael Halperin, Oded Hollander, Shachar Miller\nDeep Water Culture (DWC)\n\n\n   Bnaya Hami, Alon Dror, Michal Mannes\nBalcony gardener\n\n\n   Ran Avner, Omer Eyal, Zohar Batito\nsmart watering system"
  },
  {
    "objectID": "projects.html#final-projects-3",
    "href": "projects.html#final-projects-3",
    "title": "33   Past Final Projects",
    "section": "33.4 2021–22 Final projects",
    "text": "33.4 2021–22 Final projects\n\n\n\nTeam\nProject\n\n\n\n\n   Ronna Melamed Bat – May Nir\nMeasuring PAR outside and inside the greenhouse\n\n\n   Avital Akerman – Elad Greenfeld\nAutomated Irrigation System\n\n\n   Nadav Hen – Guy Donagi – David Zingerman\nTemporal and spatial temperature measurement in a greenhouse\n\n\n   Zeev Rozman – Imri Zadak – Alex Evenko-Greenapple\nweather station\n\n\n   Yuval Chemke – Reem Har Levi\nHydroponics Monitoring and Balance\n\n\n   Peleg Atir – Aviad Mendelovich – Ruth Yitzhaki\nVPD control using automatic sprinklers\n\n\n   Amir Sheffer – Yitzchak Kanovsky – Aviv Saadia\n3D heatmap model of a greenhouse"
  },
  {
    "objectID": "projects/borrowing-equipment.html",
    "href": "projects/borrowing-equipment.html",
    "title": "34  Borrowing equipment",
    "section": "",
    "text": "We want to give you the freedom to try out all the equipment, but we need help in tracking what equipment you took. For that reson we started a colaborative spreadsheet in which you can list the equipment you took home / are using in your project. (Only HUJI accounts can edit that sheet).\n Link to sheet\n\n34.0.1 About the sheet & some guidelines:\n\nEach unique component has its own column, including its name, brief description and link to a picture of it.\nOne row per student (please add yourself).\nInsert the amount you took of each component in numbers only.\nIn the Graveyard section write in text (example: 2 x ESP32) all the equipment that you burnt, found malfunctioning, lost, etc… Whatever we can’t use anymore… IMPORTANT: there is no shame in having a big list, honesty is what we are looking for. We are just trying to keep track of all the equipment.\nPlease make sure to immediately update the sheet as you take/return the equipment.\nNo need to list super-fundamental equipment like resistors and cables.\n\n\n\n34.0.2 We need your help:\nThe sheet is not complete and will be expanded during the semester. If there is missing information, please add/fix it. It can be:\n\nMissing component column\n\nNo description\n\nNo image link"
  },
  {
    "objectID": "projects/final-project.html#updates",
    "href": "projects/final-project.html#updates",
    "title": "35  Final Project",
    "section": "35.1 Updates",
    "text": "35.1 Updates\nPlease consult this Google Spreadsheet to be up-to-date with what’s going on with the various projects. Every team should update this spreadsheet regularly with the relevant information."
  },
  {
    "objectID": "projects/final-project.html#the-platform",
    "href": "projects/final-project.html#the-platform",
    "title": "35  Final Project",
    "section": "35.2 The platform",
    "text": "35.2 The platform\nThis year the final projects will all take place in a greenhouse on campus and will share the theme of data logging and control. Each team’s project will involve irrigation control based on sensor readings (see minimal requirements below), and will include an expansion in whatever way the group finds useful and fun.\n\nMinimal requirements:\n\nset up environmental sensors, such as temperature, humidity, soil moisture, wind, radiation, etc.\nlog all the measured data in a dedicated Thingspeak channel.\nset up an irrigation control system based on the sensed data.\n\nExtra: something cool or creative to add to this basic setup, for example\n\nextra sensors\ngraphical user interface such as screen with menus and buttons\ncalculations based on measurements, such as the Penman equation, using python\noptimization of water usage\nfertilization through irrigation (fertigation)\nalerts in case something malfunctions\nconsult with the lecturers regarding other ideas"
  },
  {
    "objectID": "projects/final-project.html#final-report-github-page",
    "href": "projects/final-project.html#final-report-github-page",
    "title": "35  Final Project",
    "section": "35.3 Final Report = GitHub page",
    "text": "35.3 Final Report = GitHub page\nDocumenting your project well is probably one of the most important lessons you will learn. Without documentation your projects will not live on and they will end their life right after the semester is over; you will forget what exactly you did and no one will be able to reproduce what you have done. We don’t want that for our projects…\nThe goal of the Agrotech-Lab course is to create a repository of all the cool projects made over the years. That way the projects will live forever and future students and other people around the world can learn from your work.\nWe require that each team creates a Github page including all the documentation. It should include:\n\nIntroduction: general explanation about the project and its goals\nHardware and assembly: Make the description as detailed as posible. Include many photos, links to order, datasheets etc.\nCode: Provide all code used in this project. Code should be organized with comments throughout explaining it.\nInstructions: How to make and use the project.\nExperiment: Show an example of the project “in action”.\n\nPlese note, the github page is your “final project paper/report”."
  },
  {
    "objectID": "projects/final-project.html#presentation",
    "href": "projects/final-project.html#presentation",
    "title": "35  Final Project",
    "section": "35.4 Presentation",
    "text": "35.4 Presentation\nOn the last day, when we meet to show our projects, each team will give a short talk of 5 minutes. During this talk you will touch the following points:\n\nWhat did you do?\nWhy do a project like yours?\nAre there agricultural or other benefits?\nHow did you do it? Hardware and code (no need to go over it, just explain in general).\nWhat did you learn? Show graphs and data analysis.\n\n\n35.4.1 Attention!\nPresentation is something you present to others, it does not mean a “Powerpoint presentation”. Your presentation will be solely based on your GitHub repository."
  },
  {
    "objectID": "projects/examples.html#open-day-2024",
    "href": "projects/examples.html#open-day-2024",
    "title": "36  Example projects",
    "section": "36.1 Open day 2024",
    "text": "36.1 Open day 2024\nThis project was developed by Yair Mau to the 2024 open day at the Faculty of Agriculture.\n\n36.1.1 Download:\n\n Fritzing diagram in pdf \n Fritzing diagram in fzz \n Code to upload to your ESP32 \n Python code to plot live the measured data \n\n\n\n36.1.2 Materials needed:\n\nESP32 Firebeetle 2\nBreadboard, wires, LED, relay, 330-ohm resistor\nSHT31 temperature and humidity sensor\nFan\nPower supply\nA computer to plot live data\n\n\n\n36.1.3 What this project is about:\nWhenever relative humidity goes above a given threshold (e.g. 80%), the fan turns on. When RH goes below threshold, fan turns off. The ESP32 must be connected to a computer, and you must run the python code. The python code communicates serially with the ESP32, and also shows on the screen a live graph of temperature and relative humidity."
  },
  {
    "objectID": "projects/mqtt_example.html#intro",
    "href": "projects/mqtt_example.html#intro",
    "title": "38  MQTT example",
    "section": "38.1 Intro",
    "text": "38.1 Intro\nEach FireBeetle board connects to Wi-Fi and subscribes to an MQTT topic. Whenever a new message is published to the topic, the board receives it and changes the color of its built-in RGB LED accordingly.\n\n38.1.1 MQTT Topic\nThe board listens to the following topic:\nagrotech/mqtt_tutorial/LED\nYou can publish messages to this topic using an MQTT client, such as the MQTTX Web Client. Make sure to connect to the broker broker.emqx.io on port 1883.\n\n\n38.1.2 Supported Commands\nYou can send color commands in various formats:\n\n38.1.2.1 🔤 Named Colors\nYou can use full names or single-letter shorthands (case-insensitive):\n\n\n\nCommand\nResulting Color\n\n\n\n\nred or r\n🔴 Red\n\n\ngreen or g\n🟢 Green\n\n\nblue or b\n🔵 Blue\n\n\nwhite or w\n⚪ White\n\n\nyellow or y\n🟡 Yellow\n\n\ncyan or c\n🟦 Cyan\n\n\nmagenta or m\n🟣 Magenta\n\n\noff or black\n⚫ LED Off\n\n\n\n\n\n38.1.2.2 🎨 Custom RGB Triplets\nYou can also send a custom color as a comma-separated RGB value, e.g.:\n255,100,0\nThis would set the LED to an orange-like color. The values should range from 0 to 255.\n\nThis setup is ideal for remote visual feedback or synchronized color indicators across multiple ESP32 boards on the same MQTT topic."
  },
  {
    "objectID": "projects/mqtt_example.html#led-subscribe",
    "href": "projects/mqtt_example.html#led-subscribe",
    "title": "38  MQTT example",
    "section": "38.2 LED subscribe",
    "text": "38.2 LED subscribe\n\n     Toggle code\n    \n     \n         Download code\n    \n\n            \n            \n        \n#include &lt;Arduino.h&gt;\n#include &lt;WiFi.h&gt;\n#include &lt;PubSubClient.h&gt;\n#include &lt;Adafruit_NeoPixel.h&gt;\n\n#define LED_PIN    5  // built-in WS2812 RGB on FireBeetle 2 = GPIO5 (D8)\n#define NUM_LEDS   1\n#define BRIGHTNESS 50\n\nconst char* ssid = \"erez\";         // &lt;-- change this\nconst char* password = \"arduino1\"; // &lt;-- change this\nconst char* mqttServer = \"broker.emqx.io\";  // &lt;== NEW BROKER\nint mqttPort = 1883;\nconst char* mqttTopic = \"agrotech/mqtt_tutorial/LED\";\n\nWiFiClient wifiClient;\nPubSubClient mqttClient(wifiClient);\nAdafruit_NeoPixel strip(NUM_LEDS, LED_PIN, NEO_GRB + NEO_KHZ800);\n\nString msgString;\n\nvoid setColor(uint8_t r, uint8_t g, uint8_t b) {\n  strip.setPixelColor(0, strip.Color(r, g, b));\n  strip.show();\n}\n\nvoid parseColor(String color) {\n  color.trim();\n  color.toLowerCase();\n\n  // named or shorthand colors\n  if (color == \"r\" || color == \"red\") setColor(255, 0, 0);\n  else if (color == \"g\" || color == \"green\") setColor(0, 255, 0);\n  else if (color == \"b\" || color == \"blue\") setColor(0, 0, 255);\n  else if (color == \"w\" || color == \"white\") setColor(255, 255, 255);\n  else if (color == \"y\" || color == \"yellow\") setColor(255, 255, 0);\n  else if (color == \"m\" || color == \"magenta\") setColor(255, 0, 255);\n  else if (color == \"c\" || color == \"cyan\") setColor(0, 255, 255);\n  else if (color == \"off\" || color == \"black\") setColor(0, 0, 0);\n  else if (color.indexOf(',') != -1) {\n    // RGB triplet: \"100,200,30\"\n    int r = color.substring(0, color.indexOf(',')).toInt();\n    int g = color.substring(color.indexOf(',') + 1, color.lastIndexOf(',')).toInt();\n    int b = color.substring(color.lastIndexOf(',') + 1).toInt();\n    setColor(r, g, b);\n  }\n  else {\n    Serial.println(\"Unknown color command\");\n  }\n}\n\nvoid callback(char* topic, byte* message, unsigned int length) {\n  msgString = String((char*)message, length);\n  Serial.print(\"MQTT message received: \");\n  Serial.println(msgString);\n  parseColor(msgString);\n}\n\nvoid setupMQTT() {\n  mqttClient.setServer(mqttServer, mqttPort);\n  mqttClient.setCallback(callback);\n}\n\nvoid reconnect() {\n  Serial.println(\"Connecting to MQTT Broker...\");\n  while (!mqttClient.connected()) {\n    String clientId = \"ESP32Client-\" + String(random(0xffff), HEX);\n    if (mqttClient.connect(clientId.c_str())) {\n      Serial.println(\"Connected to MQTT.\");\n      mqttClient.subscribe(mqttTopic);\n    } else {\n      Serial.print(\".\");\n      delay(1000);\n    }\n  }\n}\n\nvoid setup() {\n  Serial.begin(115200);\n\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\\nConnected to WiFi.\");\n\n  strip.begin();\n  strip.setBrightness(BRIGHTNESS);\n  strip.show(); // off\n\n  setupMQTT();\n}\n\nvoid loop() {\n  if (!mqttClient.connected()) reconnect();\n  mqttClient.loop();\n}"
  }
]